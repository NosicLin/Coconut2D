"#export native"
"#export web"
"#include Coconut.js"
"#include GridSymbol.jspp"
"#include SceneGameBoard.jspp"
"#include SceneTitle.jspp"
"#include GridSymbol.jspp"

// ==================================================================================================================================
//	   ______                     ______            _
//	  / ____/___ _____ ___  ___  / ____/___  ____ _(_)___  ___
//	 / / __/ __ `/ __ `__ \/ _ \/ __/ / __ \/ __ `/ / __ \/ _ \
//	/ /_/ / /_/ / / / / / /  __/ /___/ / / / /_/ / / / / /  __/
//	\____/\__,_/_/ /_/ /_/\___/_____/_/ /_/\__, /_/_/ /_/\___/
//	                                      /____/
// ==================================================================================================================================

state class GameEngine : CocoEngine
{
	private var scene:CocoScene;				// The current scene.

	private var balance:Number; 	 			// User's Balance.
	private var winnings:Number;  				// User's Round Winnings.

	private var avatars:Array<CocoClip>;		// Array of avatars.
	private var avatar_leo:CocoClip;            // Avatar of Leonidas.
	private var avatar_xerxes:CocoClip;         // Avatar of Xerxes.
	private var avatar_spartan:CocoClip;        // Avatar of Spartan.
	private var avatar_persian:CocoClip;        // Avatar of Persian.
	private var avatar_swords:CocoClip;         // Avatar of Swords.
	private var avatar_armor:CocoClip;          // Avatar of Armor.

	private var btnOpenAll:CocoClip;			// Open All Button.
	private var btnBuyTicket:CocoClip;			// Buy Ticket Button.
	private var cells:Array<CocoClip>;          // Array of Grid Cells.
	private var cellsOpen:Array<Boolean>;       // Array of opened Cells.

	private var selectedAvatar:Integer;			// User's selected avatar.
	private var selAvatarAppearances:Integer;   // Number of appearances of user's selected avatar.
	private var counter:Number;    				// Used by createGUID.

	// Default ticket for debugging purposes
	private var TICKET_TicketID:String;         // Ticket ID.
	private var TICKET_cells:Array<Integer>; 	// Array of avatar indexes returned from "Server".
	private var TICKET_price:Integer;           // Ticket price.
	private var TICKET_winCount:Integer;		// Number of minimum appearances of the selected avatar needed to win.
	private var WIN_PRIZES:Array<Integer>;      // Prize table values.

	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor()
	{
		// Initializations.
		selectedAvatar 			= -1;
		selAvatarAppearances 	= 0;
		counter 				= 0;
		TICKET_price 			= 5;
		TICKET_winCount 		= 3;
		WIN_PRIZES 				= [0, 0, 0, 5, 50, 100, 500, 5000];

		// Go to next state - Show title screen.
		setNextState(STATE_TITLE_SCREEN);
	}


	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		delete scene;
	}


	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public state STATE_TITLE_SCREEN
	{
		function enter()
		{
			scene = new SceneTitle();
		}

		function exit()
		{
			delete scene;
		}

		function tick(time:Time)
		{
			// Go to next state - When animation is completed, go to next scene.
			if(scene.__finished)
				setNextState(STATE_GAME_BOARD);
		}

		function paint(gl:WebGLRenderingContext, time:Time)
		{
			scene.paint(gl, time);
		}
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public state STATE_GAME_BOARD
	{
		function enter()
		{
			// Game Board scene initialization.
			scene = new SceneGameBoard();

			avatar_leo 		= scene.__root.getChildByName("Avatar_Leonidas");
			avatar_xerxes	= scene.__root.getChildByName("Avatar_Xerxes");
			avatar_spartan	= scene.__root.getChildByName("Avatar_Spartan");
			avatar_persian	= scene.__root.getChildByName("Avatar_Persian");
			avatar_swords  	= scene.__root.getChildByName("Avatar_Swords");
			avatar_armor	= scene.__root.getChildByName("Avatar_Armor");

			btnBuyTicket	= scene.__root.getChildByName("BuyTicketButton");
			btnOpenAll		= scene.__root.getChildByName("OpenAllButton");

			cells 			= scene.__root.getChildByName("Grid").__children.slice(0, 12);
			cellsOpen		= [false, false, false, false, false, false, false, false, false, false, false, false];
			avatars 		= [avatar_leo, avatar_xerxes, avatar_spartan, avatar_persian, avatar_swords, avatar_armor];

			balance = 5000;
			TICKET_TicketID	= createGUID();
			TICKET_cells.clear();
		}

		function exit()
		{
		}

		function tick(time:Time)
		{
		}

		function paint(gl:WebGLRenderingContext, time:Time)
		{
			scene.paint(gl, time);
		}
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////
    public state STATE_JUMPING_AVATARS
    {
    	function enter()
    	{
	 		// Move timeline playhead to the keyframe labeled JumpingAvatars.
	 		scene.gotoAndPlayByName("JumpingAvatars");

	 		// Move internal playhead of each of the CocoClips in avatars to keyframe
	 		// named as Enable and play the animation to make all avatars selectable.
	 		// If user has already made a selection from a previous turn, the previously
	 		// selected avatar won't be affected.
	 		for(var i:Integer = avatars.size(); i--;)
	 			if(i != selectedAvatar)
					avatars[i].gotoFrameByName("Enable", false);
    	}

    	function exit()
    	{
    	}

    	function tick(time:Time)
    	{
    	}

		function paint(gl:WebGLRenderingContext, time:Time)
		{
			scene.paint(gl, time);
		}
    }

	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public state STATE_GAME_BOARD_CHOOSE_AVATAR
	{
		function enter()
		{
			// Stop the scene's playhead to currentFrame.
			scene.stop();

			// If user has selected an avatar, make the Buy Ticket button clickable.
			if(selectedAvatar != -1)
				btnBuyTicket.gotoFrameByName("Enabled", true);

			// Variables initialization for this turn.
			selAvatarAppearances = 0;
			TICKET_cells.clear();
		}

		function exit()
		{
			// Prepare scene for the next state.
			// Show prize table and initialize grid cells.
			scene.__root.getChildByName("PrizeTable").gotoFrameByName("Show", false);
        	for(var i:Integer = cells.size(); i--;)
        	{
        		// Move playhead to closed.
        		cells[i].gotoFrameByName("closed", true);

        		//Initialize cellsOpen to indicate all cells are closed.
        		cellsOpen[i] = false;

        		// Get the layer labeled as Back from each cell CocoClip.
        		var back:CocoClip = cells[i].getChildByName("Back");

        		// Remove the avatar image from the layer.
        		back.removeChild(back.getChildByName("Placeholder"));
        	}
		}

		function tick(time:Time)
		{
			// Case when user has already select an avatar from a previous turn and clicks on Buy Ticket button.
			if(selectedAvatar != -1 && engine.isClicked([btnBuyTicket]) != -1)
			{
				// Make other avatars unselectable.
				for(var i:Integer = avatars.size(); i--;)
					if(i != selectedAvatar)
						avatars[i].gotoFrameByName("Disable", false);

                // Subtract the TICKET_price from user's balance and show it to user.
				balance -= TICKET_price;
				// txtBalance.text -= TICKET_price;

				// Go to next state.
				setNextState(STATE_GAME_BOARD_SCRATCH_OR_OPEN_ALL);
			}

            // Wait for avatar to be clicked.
			var clickedAvatar:Number = engine.isClicked(avatars);
			if(clickedAvatar != -1)
			{
				// Make other avatars unselectable.
				if(selectedAvatar == clickedAvatar)
				{
					for(var i:Integer = avatars.size(); i--;)
						if(i != selectedAvatar)
							avatars[i].gotoFrameByName("Disable", false);
				}
				else
				{
					for(var i:Integer = avatars.size(); i--;)
						avatars[i].gotoFrameByName((i == clickedAvatar ? "Select" : "Disable"), false);
				}

				// Update selectedAvatar variable with the newly selected one.
                selectedAvatar = clickedAvatar;

                // Go to next state.
				setNextState(STATE_GAME_BOARD_BUY_TICKET);
			}
		}

		function paint(gl:WebGLRenderingContext, time:Time)
		{
			scene.paint(gl, time);
		}
	}


	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public state STATE_GAME_BOARD_BUY_TICKET
	{
		function enter()
		{
        	// Progress the scene animation. Move scene's timeline playhead to
        	// Keyframe WaitToBuyTicket and stop. Make Buy Ticket button clickable.
        	scene.gotoAndStopByName("WaitToBuyTicket");
        	btnBuyTicket.gotoFrameByName("Enabled", true);
		}

		function exit()
		{
		}

		function tick(time:Time)
		{
			// When user clicks on Buy Ticket button, get a new Ticket from server and
			// subtract the TICKET_price from user's balance and show it to user.
			if(engine.isClicked([btnBuyTicket])!=-1) {
				TICKET_TicketID = createGUID();

				balance -= TICKET_price;
				var blnce:Number = balance;
				// txtBalance.text -= TICKET_price;

				// Go to next state.
				setNextState(STATE_GAME_BOARD_SCRATCH_OR_OPEN_ALL);
			}
		}

		function paint(gl:WebGLRenderingContext, time:Time)
		{
			scene.paint(gl, time);
		}

	}


	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public state STATE_GAME_BOARD_SCRATCH_OR_OPEN_ALL
	{
		var gridSymbol:GridSymbol;
		var Leonidas:CocoClip;
		var Xerxes:CocoClip;

		function enter()
		{
			gridSymbol = new GridSymbol(scene);

        	scene.gotoAndStopByName("WaitToScratch");

            // Disable Buy Ticket button and make Open All button clickable.
            btnBuyTicket.gotoFrameByName("Disable", false);
        	btnOpenAll.gotoFrameByName("Enabled", true);

            // Animate Leonidas and Xerxes figures at the back.
        	Leonidas = scene.__root.getChildByName("Leonidas");
        	Xerxes = scene.__root.getChildByName("Xerxes");
        	Leonidas.gotoFrameByName("Animate", false);
        	Xerxes.gotoFrameByName("Animate", false);

         	// Get random values for Ticket and add the corresponding image at
         	// the Back layer of each grid cell.
         	TICKET_cells.clear();
        	for(var i:Integer = 0; i < cells.size(); i++)
        	{
        		TICKET_cells.push(gridSymbol.getRandom());
        		cells[i].getChildByName("Back").addChild(gridSymbol.createSymbol(TICKET_cells[i]));
        	}
		}

		function exit()
		{
			// Disable Open All button and stop the animation from Leonidas and Xerxes figures.
			btnOpenAll.gotoFrameByName("Disable", false);
			Leonidas.gotoFrameByIndex(0, true);
        	Xerxes.gotoFrameByIndex(0, true);
		}

		function tick(time:Time)
		{
			// If button Open All is clicked, go to next state.
			if(engine.isClicked([btnOpenAll]) != -1)
				setNextState(STATE_GAME_BOARD_OPEN_ALL);

            // Check if a grid cell is clicked and play animation.
			OpenCell(engine.isClicked(cells));

			// If the number of selected avatar visible on screen is the minimum required
			// for the player to win, then go to next state and open the remaining closed cells.
			if(TICKET_winCount == selAvatarAppearances)
				setNextState(STATE_GAME_BOARD_OPEN_ALL);

            // In case that all the grid cells are opened, go to next state.
			if(!hasClosedCells())
			{
				if(selAvatarAppearances >=3)
					setNextState(STATE_GAME_BOARD_WIN);
				else
					setNextState(STATE_GAME_BOARD_LOSE);
				var noWinningAvatars:Integer = selAvatarAppearances;
			}
		}

		function paint(gl:WebGLRenderingContext, time:Time)
		{
			scene.paint(gl, time);
		}
	}


	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public state STATE_GAME_BOARD_OPEN_ALL
	{
		var openTicks:Integer;
		var count:Integer;

		function enter()
		{
			openTicks = 5;
			count = 0;
		}

		function exit()
		{
		}

		function tick(time:Time)
		{
			// Open closed grid cells in specific order.
			if(!(count % openTicks))
			{
				var i:Integer = count / openTicks;
				switch(i)
				{
					case 0: OpenCell(11); break;
					case 1: OpenCell(1); OpenCell(2); break;
					case 2: OpenCell(3); OpenCell(4); OpenCell(5); break;
					case 3: OpenCell(6); OpenCell(7); OpenCell(8); break;
					case 4: OpenCell(9); OpenCell(10); break;
					case 5: OpenCell(0); break;
					default:
						if(selAvatarAppearances >= 3)
							setNextState(STATE_GAME_BOARD_WIN);
						else
							setNextState(STATE_GAME_BOARD_LOSE);
				}
			}
            count++;
		}

		function paint(gl:WebGLRenderingContext, time:Time)
		{
			scene.paint(gl, time);
		}
	}


	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public state STATE_GAME_BOARD_WIN
	{
		function enter()
		{
			setTexts();

			// Go to Win animation and stop.
			scene.gotoAndStopByName("WinAnim");
			for(var i:Integer = cells.size(); i--;)
        	{
        		// For each grid cell, play the win or lose animation, based on the ticket's value.
        		if(selectedAvatar == (TICKET_cells[i] - 1))
        			cells[i].gotoFrameByName("Winner", false);
        		else
        			cells[i].gotoFrameByName("Looser", false);
        	}
		}

		function exit()
		{
			// Reset win animation.
			var win:CocoClip = scene.__root.getChildByName("YouWin");
			win.gotoFrameByIndex(0, false);
		}

		function tick(time:Time)
		{
		}

		function paint(gl:WebGLRenderingContext, time:Time)
		{
			scene.paint(gl, time);
		}
	}


	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public state STATE_GAME_BOARD_LOSE
	{
		function enter()
		{
			// Go to state JumpingAvatars.
			setNextState(STATE_JUMPING_AVATARS);
		}

		function exit()
		{
		}

		function tick(time:Time)
		{
		}

		function paint(gl:WebGLRenderingContext, time:Time)
		{
			scene.paint(gl, time);
		}

	}


    //////////////////////////////////////////////////////////////////////////////////////////////////////
    public function setTexts()
    {
    	// Update user balance and winnings and present them to user.
    	balance += WIN_PRIZES[selAvatarAppearances];
    	var blnce:Number = balance;
    	//txtBalance.text = balance;
    	//txtWinnings.text = ((selAvatarAppearances>2) ? WIN_PRIZES[selAvatarAppearances] : 0);
    }


	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//createGUID()
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public function createGUID():String
	{
		var list:Array<String> = ["87D2C004-1441-4CD5-AEB3-E221BA96C9B8", "23FCC6FD-2E17-49ED-85E3-21AFB67A9FA5", "F09FEBCF-7541-43F3-BFE5-EE48EC44A3AD", "F6C2F6D2-5B47-4E0F-A6EC-DAE78AADCE47", "7798C232-4859-4FF8-93BD-8CE68D1F0718", "46F61FE6-A48A-45D6-A96E-2E2E83D9A21A"];
		return list[Math.floor(Math.random() * list.size())];
	}

    public function hasClosedCells() : Boolean
    {
        for(var c:Integer = cellsOpen.size(); c--;)
        	if(!cellsOpen[c])
        		return true;
        return false;
    }

    public function OpenCell(i:Integer)
    {
    	if(i != -1 && !cellsOpen[i])
		{
			cells[i].gotoFrameByName("flip", false);
			cellsOpen[i] = true;
			if(selectedAvatar == (TICKET_cells[i] - 1)) selAvatarAppearances++;
		}
    }

}
