"#export native";
"#export web";

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2014 www.coconut2D.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	   ______				  _________
//	  / ____/___  _________  / ____/ (_)___
//	 / /   / __ \/ ___/ __ \/ /   / / / __ \
//	/ /___/ /_/ / /__/ /_/ / /___/ / / /_/ /
//	\____/\____/\___/\____/\____/_/_/ .___/
//								   /_/
// ==================================================================================================================================

/**
 * CocoClip encapsulates reusable pieces of animation and are the basic animation mechanism in Coconut2D.
 * CocoClips have their own multiframe timeline that can contain interactive controls, sounds, and even
 * other CocoClip instances. At runtime a CocoClip can be either a container of other CocoClips refered
 * as "container clip" or it can animate a single image, refered as "primitive clip".
 *
 * The functionality of a CocoClip is rather straight forward. Each CocoClip receives as input a "transformation
 * matrix" from its parent clip and combines it (multiplies it) with its current timeline interpolation frame.
 * The resulting transformation matrix is used to either paint the image (if it is a primitive) or its children
 * clips (if it is a container).
 *
 * When a CocoClip needs to calculate the current timeline frame it uses time-interpolation; it simply finds
 * the previous and next KeyFrames for a given time and performs linear interpolation in order to calculate
 * the key transformation values (translation, rotation, scale, alpha, etc.).
 *
 * A CocoClip can be set to calculate its bounding rectanble or bounding box. That is the rectangle used to
 * fully encapsulate either its image (if it is a primitive) or its children (if it is a container). Bounding
 * boxes are used for hit-tests so that we can detect when a user clicks/touches a CocoClip. Bounding box
 * calculation is somewhat expensive because it involves multiplication of matrixes and vectors, so we only
 * do it when the animation engine requests it on the current cycle so that it is available on the next.
 * This actually means that there is a 16ms delay from the time a user places his finger on the screen
 * before we are able to respond to it.
 *
 * CocoClips can also animate "Sprite Animation Sequences" if they detect that the primitive image has
 * spritesheet information associated with it.
 *
 * Last but not least, CocoClip API offers several animation control functions such as gotoFrameByName
 * and gotoFrameByIndex that jump the animation to a specific keyframe or time label. This feature is
 * used for programmatically controlling your animations and games.
 *
 * @module CocoClip.jspp
 * @version 0.1
 * @author Elias Politakis <epolitakis@mobilefx.com>
 * @copyright www.coconut2D.org 2013-2014
 * @tutorial
 * @summary CocoClips encapsulate reusable pieces of animation
 * @description CocoClips encapsulate reusable pieces of animation
 */

"#include CocoTimeline.jspp";

class CocoClip : CocoEventSource implements IEventListener, IEventTarget
{
	public var __uniqueID:String;
	public var __zIndex:Integer;
	public var __instanceName:String;
	public var __clipPath:String;
	public var __symbolLoop:COCO_CLIP_SYMBOL_LOOP_ENUM;
	public var __children:Array<CocoClip>;
	public var __timeline:CocoTimeline;

	// References to objects we do not own (do not delete in destructor)

	public reference var __scene:CocoScene;
	public reference var __image:CocoImage;
	public reference var __parent:CocoClip;
	public reference var __currentFrame:CocoKeyFrame;
	public reference var __childWithMaxTimelineDuration:CocoClip;
	public reference var __currentSequence:CocoSequence;
	public reference var __currentAudio:CocoAudio;
	public reference var __ANCHOR:HTMLDivElement;

	// Animation Control Variables
	public var __currentTime:Time;
	public var __loopTime:Time;
	public var __loops:Integer;
	public var __currentSequenceStartTime:Time;
	public var __currentSequenceFrameIndex:Integer;
	public var __pauseTicks:Integer;
	public var __visible:Boolean;

	// Bounding Box & Hit Test
	public var __x:Float;
	public var __y:Float;
	public var __width:Float;
	public var __height:Float;
	public var __hasBoundingBox:Boolean;
	public var __vABS_TOP_LEFT:CocoVector;
	public var __vABS_TOP_RIGHT:CocoVector;
	public var __vABS_BOTTOM_LEFT:CocoVector;
	public var __vABS_BOTTOM_RIGHT:CocoVector;
	public var __vREL_TOP_LEFT:CocoVector;
	public var __vREL_TOP_RIGHT:CocoVector;
	public var __vREL_BOTTOM_LEFT:CocoVector;
	public var __vREL_BOTTOM_RIGHT:CocoVector;
	public var __vBBoxVrtx:CocoVector;
	public var __mBBox:CocoMatrix;

	// Touch Control Variables
	public var __touch_start_time:Time;
	public var __touch_start_point: CocoPoint;
	public var __touch_moved:Boolean;

	// Define CocoClip events
	public event OnClick();
	public event OnTouchStart(x:Float, y:Float);
	public event OnTouchMove(x:Float, y:Float);
	public event OnTouchEnd(x:Float, y:Float);
	public event OnAnimationSequenceBegin(sequence:CocoSequence);
	public event OnAnimationSequenceEnd(sequence:CocoSequence);

	public static var __uniqueIDCounter:Integer = 0;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor(optional image:CocoImage)
	{
		__uniqueID = "__Clip" + String(++__uniqueIDCounter);

		__symbolLoop					= COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_CONTINUOUS;
		__timeline						= new CocoTimeline();
		__children						= new Array<CocoClip>;
		__parent						= null;
		__currentTime					= 0.0;
		__currentSequenceStartTime		= 0.0;
		__currentSequenceFrameIndex		= 0;
		__currentFrame					= null;
		__hasBoundingBox				= false;
		__vABS_TOP_LEFT					= new CocoVector();
		__vABS_TOP_RIGHT				= new CocoVector();
		__vABS_BOTTOM_LEFT				= new CocoVector();
		__vABS_BOTTOM_RIGHT				= new CocoVector();
		__vREL_TOP_LEFT					= new CocoVector();
		__vREL_TOP_RIGHT				= new CocoVector();
		__vREL_BOTTOM_LEFT				= new CocoVector();
		__vREL_BOTTOM_RIGHT				= new CocoVector();
		__vBBoxVrtx						= new CocoVector();
		__mBBox							= new CocoMatrix();
		__touch_start_point 			= new CocoPoint;
		__childWithMaxTimelineDuration	= null;
		__currentSequence				= null;
		__currentAudio					= null;
		__clipPath						= "";
		__instanceName					= "";
		__scene							= null;
		__loopTime						= 0;
		__loops							= 0;
		__x								= 0.0;
		__y								= 0.0;
		__width							= 0.0;
		__height						= 0.0;
		__touch_start_time				= 0;
		__touch_moved					= false;
		__image 						= image;
		__pauseTicks					= 0;
		__visible						= true;
		__zIndex						= 0;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		delete __children;
		delete __timeline;
		delete __vABS_TOP_LEFT;
		delete __vABS_TOP_RIGHT;
		delete __vABS_BOTTOM_LEFT;
		delete __vABS_BOTTOM_RIGHT;
		delete __vREL_TOP_LEFT;
		delete __vREL_TOP_RIGHT;
		delete __vREL_BOTTOM_LEFT;
		delete __vREL_BOTTOM_RIGHT;
		delete __vBBoxVrtx;
		delete __mBBox;
		delete __touch_start_point;

		if(__currentFrame && __currentFrame.__isCloned)
			delete __currentFrame;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function prepare(ctx:ICocoRenderContext, scene:CocoScene, zIndex:Integer)
	{
		__zIndex = zIndex;
		ctx.prepareClip(this);
		__timeline.prepare(scene, this);
		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			__children[i].prepare(ctx,scene,zIndex-1);
		}
		normalize();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function analyze(sx:Float, sy:Float)
	{
		var maxSX:Float = 0.0;
		var maxSY:Float = 0.0;
		var i:Integer;
		for(i = __timeline.__keyFrames.size(); i--;)
		{
			var kf:CocoKeyFrame = __timeline.__keyFrames[i];
			if(kf.scaleX > maxSX) maxSX = kf.scaleX;
			if(kf.scaleY > maxSY) maxSY = kf.scaleY;
		}
		sx *= maxSX;
		sy *= maxSY;

		if(__image)
		{
			if(__image.scaleX < sx) __image.scaleX = sx;
			if(__image.scaleY < sy) __image.scaleY = sy;
		}
		else
		{
			for(i = __children.size(); i--;)
				__children[i].analyze(sx, sy);
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function reset()
	{
		if(__currentFrame)
			delete __currentFrame;

		__currentFrame = null;
		__currentTime = 0.0;
		__timeline.reset();

		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			__children[i].reset();
		}

		if(__currentAudio)
			__currentAudio.reset();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function clear()
	{
		for(var i:Integer = __children.size()-1; i>=0; i--)
		{
			delete __children[i];
		}
		__children.clear();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function addChild(clipInstance:CocoClip) :CocoClip
	{
		if(!clipInstance) return null;
		if(!clipInstance.__instanceName) throw "Invalid instance name.";
		__children.push(clipInstance);
		clipInstance.__parent = this;
		if(__scene) clipInstance.__scene = __scene;
		normalize();
		clipInstance.__clipPath = (__clipPath ? __clipPath : __instanceName) + "/" + clipInstance.__instanceName;
		return clipInstance;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function removeChild(clipInstance:CocoClip) :CocoClip
	{
		if(!clipInstance) return null;
		var index:Integer = getChildIndex(clipInstance);
		clipInstance.__parent = null;
		if(index==-1) return null;
		__children.splice(index, 1);
		normalize();
		return clipInstance;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function moveChild(child:CocoClip, zIndex:Integer)
	{
		if(zIndex==-1) return;

		var children:Array<CocoClip> = new Array<CocoClip>;
		var i:Integer;
		var L:Integer = __children.size();

		for(i=0;i<zIndex;i++)
			if(child!=__children[i])
				children.push(__children[i]);

		children.push(child);

		for(i=zIndex;i<L;i++)
			if(child!=__children[i])
				children.push(__children[i]);

		delete __children;
		__children = children.reverse();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildByName(instanceName:String) :CocoClip
	{
		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			if(__children[i].__instanceName==instanceName)
			{
				return __children[i];
			}
		}
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildIndex(child:CocoClip) :Integer
	{
		if(child)
		{
			for(var i:Integer =__children.size()-1; i>=0; i--)
			{
				if(__children[i]==child)
				{
					return i;
				}
			}
		}
		return -1;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildrenByClassName(className:String) :Array<CocoClip>
	{
		var arr:Array<CocoClip> = new Array<CocoClip>;
		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			if(__children[i].__className==className)
			{
				arr.push(__children[i]);
			}
			arr = arr.concat(__children[i].getChildrenByClassName(className));
		}
		return arr;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////
	// Append keyframes from current position to new position
	public function moveTo(x:Float, y:Float, frames:Integer)
	{
		var frameIndex:Integer = __timeline.__lastKeyFrameIndex+1;

		var kf:CocoKeyFrame = CocoTimeline.NewKeyFrame();
		kf.frameIndex = frameIndex;
		kf.x = __currentFrame.x;
		kf.y = __currentFrame.y;
		__timeline.addKeyFrame(kf);

		kf = CocoTimeline.NewKeyFrame();
		kf.frameIndex = frameIndex+frames;
		kf.x = x;
		kf.y = y;
		kf.action = __scene.stop;
		__timeline.addKeyFrame(kf);

		__parent.gotoFrameByIndex(frameIndex,false);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function normalize()
	{
		// Find clip with max timeline duration.
		__childWithMaxTimelineDuration = null;
		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			if(!__childWithMaxTimelineDuration)
			{
				__childWithMaxTimelineDuration = __children[i];
				continue;
			}
			if(__children[i].__timeline.__durationInTime > __childWithMaxTimelineDuration.__timeline.__durationInTime)
			{
				__childWithMaxTimelineDuration = __children[i];
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoFrameByName(LabelName:String, optional pause:Boolean) :Boolean
	{
		var Label:CocoTimeLabel = __timeline.findLabelByName(LabelName);
		if(!Label) return false;

		//trace("\ngotoFrameByName: clip=" + __clipPath + ", label=" + LabelName + ", pause=" + String(pause));

		return gotoFrameByIndex(Label.frameIndex, pause);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoFrameByIndex(FrameIndex:Integer, optional pause:Boolean) :Boolean
	{
		//trace("\ngotoFrameByIndex: clip=" + __clipPath + ", index=" + (FrameIndex==-1 ? "STOP_ON_CURRENT_FRAME" : String(FrameIndex)) + ", pause=" + String(pause));

		var clip:CocoClip;
		for (var i:Integer = __children.size() - 1; i >= 0; i--)
		{
			clip = __children[i];

			if(FrameIndex==COCO_STOP_ON_CURRENT_FRAME)
				FrameIndex = clip.__currentFrame ? clip.__currentFrame.frameIndex : 0;

			clip.__pauseTicks = 0;
			clip.__timeline.__paused = pause;
			clip.__timeline.__currentFrameIndex = -1;

			clip.__currentTime = Time(FrameIndex) * clip.__timeline.__singleFrameDurationTime;

			//trace("-> child: " + clip.__clipPath + ", from=" + (clip.__currentFrame ? String(clip.__currentFrame.frameIndex) : "0") + ", to=" + String((FrameIndex==-1 ? clip.__currentFrame.frameIndex : FrameIndex)) + ", time=" + clip.__currentTime.toFixed(2) + ", paused=" + String(clip.__timeline.__paused));
		}
		return true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function paused():Boolean
	{
		var clip:CocoClip;
		for(var i:Integer = __children.size() - 1; i >= 0; i--)
			if(!__children[i].__timeline.__paused)
				return false;
		return true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function __advanceTime()
	{
		__pauseTicks++;
		if(__timeline.__paused) return;
		__currentTime += engine.TICK_TIME;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function tick(time:Time)
	{
		for(var i:Integer = __children.size(); i--;)
			__children[i].tick(time);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function paint(ctx:ICocoRenderContext, scene:CocoScene, parentClip:CocoClip, calcBoundingBox:Boolean, level:Integer)
	{
		__scene = scene;

		var mv:CocoMatrix = ctx.getModelViewMatrix();

		// Calculate the parent timeline duration in time from its children (which are siblings to this clip)
		var parentClipsDuration:Time = parentClip ? parentClip.__childWithMaxTimelineDuration.__timeline.__durationInTime : __timeline.__singleFrameDurationTime;

        // =============================================================================================================
        // Combine with parent clip and interpolate
        // =============================================================================================================
		if(parentClip)
		{
			// Calculate this clip's LoopTime which is the projection of this clip's timeline to its parent's timeline.
			__loops = Math.floor(__currentTime / parentClipsDuration);
			__loopTime = __currentTime - (Time(__loops) * parentClipsDuration);

			// Calculate frameIndex from time.
			var frameIndex:Float = __loopTime / __timeline.__singleFrameDurationTime;

			// Interpolate
			if(__currentFrame && __currentFrame.__Preserve)
			{
				// Skip frame interpolation this time
				__currentFrame.__Preserve = false;
			}
			else
			{
				if(__currentFrame) delete __currentFrame;
				__currentFrame = __timeline.interpolate(frameIndex);
			}


			// If interpolation didn't return a frame, do not advance time and exit.
			if(!__currentFrame) return;

			if(!__visible) __currentFrame.visible = false;

			// Combine parent clip currentframe values with this clip's interpolated frame values.
			 combine(__currentFrame, parentClip.__currentFrame);

			// If current frame is not visible then we skip processing children.
			if(__currentFrame.alpha == 0 || !__currentFrame.visible)
			{
				// Propagate clip's timeline.
				ctx.apply(this, __currentFrame, mv);
				__advanceTime();
				return;
			}

			// If we need to handle an event or if our parent has asked us to
			// calc our bounding box **AND** there is an actual event waiting
			// then we set calcBoundingBox to true.
			calcBoundingBox = (__currentFrame.handleEvents || calcBoundingBox) && engine.__hasTouchDeviceMessage();
		}

        // =============================================================================================================
		// RENDER!
        // =============================================================================================================

        ctx.apply(this, __currentFrame, mv);

		if(__image)
		{
			if(!__image.renderData && __image.hImage && __image.hImage.complete)
			{
				__image.renderData = engine.__ctx.prepareImage(__image);
			}

			// Failed to create image render data or image is not ready yet.
			if(!__image.renderData)
			{
				__advanceTime();
				return;
			}

			// Get sequence name, first from current clip and if not found from parent clip.
			var sequenceName:String = __currentFrame.spriteSequenceName;
			if(!sequenceName && parentClip && parentClip.__currentFrame) sequenceName = parentClip.__currentFrame.spriteSequenceName;

			// Check if we should change sprite animation sequence
			if(!sequenceName)
			{
				__currentSequence = null;
				__currentSequenceFrameIndex = -1;
			}
			else if(!__currentSequence || __currentSequence.name!=sequenceName)
			{
				__currentSequence = __image.getSequence(sequenceName);
				__currentSequenceStartTime = __currentTime;
				__currentSequenceFrameIndex = -1;
				dispatchEvent(this.OnAnimationSequenceBegin, __currentSequence);
			}

			if(__image.isSpriteSheet && __currentSequence)
			{
				// Render animation sequence.
				var sequenceFPS:Float = __currentFrame.spriteSequenceFPS>0 ? __currentFrame.spriteSequenceFPS : scene.__fps;
				var sequenceFrameIndex:Integer = __timeline.__paused ? 0 : Math.floor((__currentTime-__currentSequenceStartTime) / (1000.0 / sequenceFPS)) % __currentSequence.frames.size();
				var frame:Integer = __currentSequence.frames[sequenceFrameIndex];

				if(!__ANCHOR)
				{
					ctx.drawFrame(scene, this, __image, __currentFrame, frame);
				}

				if(__currentSequenceFrameIndex!=-1 && sequenceFrameIndex<__currentSequenceFrameIndex)
				{
					dispatchEvent(this.OnAnimationSequenceEnd, __currentSequence);
				}
				__currentSequenceFrameIndex = sequenceFrameIndex;
			}
			else
			{
				// Render a standard image.
				if(!__ANCHOR)
				{
					ctx.drawFrame(scene, this, __image, __currentFrame, 0);
				}
			}
		}
		else
		{
			var childrenCount:Integer = __children.size();
			if(childrenCount>0)
			{
				var calcBoundingBoxChildren:Boolean = (calcBoundingBox && __width==0 && __height==0);
				var child:CocoClip;
				scene.__levelParents.push(this);
				for (var i:Integer = 0; i < childrenCount; i++)
				{
					mv.push();
					child = __children[i];
					child.paint(ctx, scene, this, calcBoundingBoxChildren, level+1);
					mv.pop();
				}
				scene.__levelParents.pop();
			}
		}

		if(this!=scene.__root)
		{
	        // =============================================================================================================
			// Calculare bounding box
	        // =============================================================================================================
			if(calcBoundingBox)
			{
				// Calculate bounding box from explicit width x height (eg. skin, CocoUIView, etc.)
				if(__width > 0 || __height > 0)
					initBoundingBoxFromRect(ctx, mv, __width/2, __height/2);

				// Calculate bounding box vertices
				else if(__image)
				{
					var s:Float = (scene.__view_pixel_ratio/__image.pixelRatio)/2.0;
					initBoundingBoxFromRect(ctx, mv, __image.textureCellWidth*s, __image.textureCellHeight*s);
				}

				// Calculate bounding box from children
				else if(__children.size()>0)
					initBoundingBoxFromChildren(ctx, scene, mv);
			}

	        // =============================================================================================================
			// Handle touch event
	        // =============================================================================================================
			if(calcBoundingBox && __currentFrame.handleEvents)
			{
				var deviceMessage:DEVICE_MESSAGE = engine.__peekDeviceMessage(DEVICE_MESSAGE_ENUM.MESSAGE_TOUCH_MASK);
				if(deviceMessage && !deviceMessage.handled)
				{
		   	        var x:Float = scene.worldX(deviceMessage.x0);
					var y:Float = scene.worldY(deviceMessage.y0);

					// Point in quad?
					if(hitTest(x,y))
		   	        {

		   	        	// We need the same x,y regardless of view port and screen aspect ratio.
			 			x = scene.viewX(x);
			 			y = scene.viewY(y);

		   	        	//trace("hit: " + __instanceName );
		   	        	switch(deviceMessage.type)
		   	        	{
						case DEVICE_MESSAGE_ENUM.MESSAGE_TOUCH_START:
							__touch_start_time = engine.__clock;
							__touch_start_point.x = x;
							__touch_start_point.y = y;
							dispatchEvent(this.OnTouchStart, x, y);
							if(this.OnTouchStart.stopPropagation)
							{
								deviceMessage.handled = true;
							}
							break;

						case DEVICE_MESSAGE_ENUM.MESSAGE_TOUCH_MOVE:
							dispatchEvent(this.OnTouchMove, x, y);
							if(this.OnTouchMove.stopPropagation)
							{
								deviceMessage.handled = true;
							}
							break;
		   	        	}
		   	        }

		   	        if(__touch_start_time)
		   	        {
			   	        switch(deviceMessage.type)
			   	        {
						case DEVICE_MESSAGE_ENUM.MESSAGE_TOUCH_END:
							dispatchEvent(this.OnTouchEnd, x, y);
							if(this.OnTouchEnd.stopPropagation)
							{
								deviceMessage.handled = true;
							}
							else if(Math.abs(__touch_start_point.x-x)<COCO_CONTROL_MOVE_SNAP_PIXELS && Math.abs(__touch_start_point.y-y)<COCO_CONTROL_MOVE_SNAP_PIXELS)
							{
								//If the clip hasn't moved significantly, then it is a click
								//trace("click: " + __instanceName);
								dispatchEvent(this.OnClick);
								engine.__pushClicked(this);
							}
							__touch_start_time = 0;
							break;
			   	        }
		   	        }
				}
			}

	        // =============================================================================================================
			// Execute KeyFrame
	        // =============================================================================================================

			if(!__timeline.__paused)
			{
				if(__currentFrame.action)
				{
					//engine.__trace(scene, this, "@@ACTION");
					__currentFrame.action.call(scene);
				}

				if(__currentFrame.nextState)
				{
					//engine.__trace(scene, this, "@@NEXT_STATE");
					engine.setNextState(__currentFrame.nextState);
				}

				if(__currentFrame.audio)
				{
					//engine.__trace(scene, this, "@@AUDIO");
					__currentFrame.audio.tick();
				}

		        // =============================================================================================================
				// Audio Management (the trick here is not to reset a background sound when executing an action)
		        // =============================================================================================================
				if(__currentFrame.audio)
				{
					if(__currentAudio && ((__currentFrame.audio != __currentAudio) || (__currentAudio.loops!=0)))
						__currentAudio.reset();
					__currentAudio = __currentFrame.audio;
				}
			}

	        // =============================================================================================================
			// Tick audio
	        // =============================================================================================================
			if(__currentAudio)
			{
				__currentAudio.tick();
				if(__currentAudio.ended())
				{
					__currentAudio.reset();
					__currentAudio = null;
				}
			}
		}

		// =============================================================================================================
		// Propagate clip's timeline.
		// =============================================================================================================
		__advanceTime();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function combine(F1:CocoKeyFrame, F2:CocoKeyFrame)
	{
		if(!F2) return;
		if(!F1.filter) F1.filter = F2.filter;
		F1.red = F1.red * F2.red;
		F1.green = F1.green * F2.green;
		F1.blue = F1.blue * F2.blue;
	    F1.alpha = F1.alpha * F2.alpha;
	    F1.visible = F1.visible && F2.visible;
	    F1.flipH = (F1.flipH && !F2.flipH) || (!F1.flipH && F2.flipH);
	    F1.flipV = (F1.flipV && !F2.flipV) || (!F1.flipV && F2.flipV);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function hitTest(wx:Float, wy:Float) :Boolean
	{
		return ((((wx - __vABS_TOP_LEFT.X) * (__vABS_TOP_RIGHT.Y - __vABS_TOP_LEFT.Y) - (__vABS_TOP_RIGHT.X - __vABS_TOP_LEFT.X) * (wy - __vABS_TOP_LEFT.Y)) * ((wx - __vABS_BOTTOM_RIGHT.X) * (__vABS_BOTTOM_LEFT.Y - __vABS_BOTTOM_RIGHT.Y) - (__vABS_BOTTOM_LEFT.X - __vABS_BOTTOM_RIGHT.X) * (wy - __vABS_BOTTOM_RIGHT.Y))) > 0
			&& (((wx - __vABS_TOP_RIGHT.X) * (__vABS_BOTTOM_RIGHT.Y - __vABS_TOP_RIGHT.Y) - (__vABS_BOTTOM_RIGHT.X - __vABS_TOP_RIGHT.X) * (wy - __vABS_TOP_RIGHT.Y)) * ((wx - __vABS_BOTTOM_LEFT.X) * (__vABS_TOP_LEFT.Y - __vABS_BOTTOM_LEFT.Y) - (__vABS_TOP_LEFT.X - __vABS_BOTTOM_LEFT.X) * (wy - __vABS_BOTTOM_LEFT.Y))) > 0);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function initBoundingBoxFromRect(ctx:ICocoRenderContext, mv:CocoMatrix, W2:Float, H2:Float)
	{
		__mBBox.identity();

		ctx.apply(this, __currentFrame, __mBBox);

		__vBBoxVrtx.reset(-W2, -H2, 0, 1);
		__vREL_TOP_LEFT	= __mBBox.multiplyByVector(__vBBoxVrtx);
		__vABS_TOP_LEFT	= mv.multiplyByVector(__vBBoxVrtx);

		__vBBoxVrtx.reset(W2, -H2, 0, 1);
		__vREL_TOP_RIGHT = __mBBox.multiplyByVector(__vBBoxVrtx);
		__vABS_TOP_RIGHT = mv.multiplyByVector(__vBBoxVrtx);

		__vBBoxVrtx.reset(-W2, H2, 0, 1);
		__vREL_BOTTOM_LEFT = __mBBox.multiplyByVector(__vBBoxVrtx);
		__vABS_BOTTOM_LEFT = mv.multiplyByVector(__vBBoxVrtx);

		__vBBoxVrtx.reset(W2, H2, 0, 1);
		__vREL_BOTTOM_RIGHT	= __mBBox.multiplyByVector(__vBBoxVrtx);
		__vABS_BOTTOM_RIGHT = mv.multiplyByVector(__vBBoxVrtx);

	    __hasBoundingBox = true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function initBoundingBoxFromChildren(ctx:ICocoRenderContext, scene:CocoScene, mv:CocoMatrix)
	{
	    // This function calculates the bounding box of all our children.

	    __hasBoundingBox = false;

	    if(__children.size()==0)
	    	return;

	    __vREL_TOP_LEFT.X = 100000;
		__vREL_TOP_RIGHT.X = -100000;
	    __vREL_TOP_LEFT.Y = 100000;
	    __vREL_BOTTOM_LEFT.Y = -100000;

        var Child :CocoClip
        var L:Integer = __children.size();
        for (var i:Integer = 0; i < L; i++)
	    {
            Child = __children[i];
            if(Child.__hasBoundingBox)
            {
				if(Child.__vREL_TOP_LEFT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_TOP_LEFT.X;
				if(Child.__vREL_TOP_LEFT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_TOP_LEFT.X;
				if(Child.__vREL_TOP_LEFT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_TOP_LEFT.Y;
				if(Child.__vREL_TOP_LEFT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_TOP_LEFT.Y;

				if(Child.__vREL_TOP_RIGHT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_TOP_RIGHT.X;
				if(Child.__vREL_TOP_RIGHT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_TOP_RIGHT.X;
				if(Child.__vREL_TOP_RIGHT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_TOP_RIGHT.Y;
				if(Child.__vREL_TOP_RIGHT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_TOP_RIGHT.Y;

				if(Child.__vREL_BOTTOM_LEFT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_BOTTOM_LEFT.X;
				if(Child.__vREL_BOTTOM_LEFT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_BOTTOM_LEFT.X;
				if(Child.__vREL_BOTTOM_LEFT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_BOTTOM_LEFT.Y;
				if(Child.__vREL_BOTTOM_LEFT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_BOTTOM_LEFT.Y;

				if(Child.__vREL_BOTTOM_RIGHT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_BOTTOM_RIGHT.X;
				if(Child.__vREL_BOTTOM_RIGHT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_BOTTOM_RIGHT.X;
				if(Child.__vREL_BOTTOM_RIGHT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_BOTTOM_RIGHT.Y;
				if(Child.__vREL_BOTTOM_RIGHT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_BOTTOM_RIGHT.Y;
            }
	    }

	    __vREL_TOP_RIGHT.Y = __vREL_TOP_LEFT.Y;
	    __vREL_BOTTOM_LEFT.X = __vREL_TOP_LEFT.X;
	    __vREL_BOTTOM_RIGHT.X = __vREL_TOP_RIGHT.X;
	    __vREL_BOTTOM_RIGHT.Y = __vREL_BOTTOM_LEFT.Y;

	    __vABS_TOP_LEFT = mv.multiplyByVector(__vREL_TOP_LEFT);
	    __vABS_TOP_RIGHT = mv.multiplyByVector(__vREL_TOP_RIGHT);
	    __vABS_BOTTOM_LEFT = mv.multiplyByVector(__vREL_BOTTOM_LEFT);
	    __vABS_BOTTOM_RIGHT = mv.multiplyByVector(__vREL_BOTTOM_RIGHT);

		__mBBox.identity();

		ctx.apply(this, __currentFrame, __mBBox);

	    __vREL_TOP_LEFT = __mBBox.multiplyByVector(__vREL_TOP_LEFT);
	    __vREL_TOP_RIGHT = __mBBox.multiplyByVector(__vREL_TOP_RIGHT);
	    __vREL_BOTTOM_LEFT = __mBBox.multiplyByVector(__vREL_BOTTOM_LEFT);
	    __vREL_BOTTOM_RIGHT = __mBBox.multiplyByVector(__vREL_BOTTOM_RIGHT);

	    __hasBoundingBox = true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function createInplaceHTML(optional update:Boolean, optional tag:String, optional href:String) :HTMLDivElement
	{
		var ANCHOR:HTMLDivElement = document.getElementById(__uniqueID);

		if(!ANCHOR || update)
		{
			if(ANCHOR) ANCHOR.parentNode.removeChild(ANCHOR);

			if(tag=="") tag = "DIV";

			ANCHOR = document.createElement(tag);
			ANCHOR.id = __uniqueID;
			ANCHOR.setAttribute("instanceName", __instanceName);

			ANCHOR.style.display				= "block";
			ANCHOR.style.position				= "absolute";
			ANCHOR.style.top					= "0px";
			ANCHOR.style.left					= "0px";
			ANCHOR.style.width					= String(__image.textureCellWidth/__image.pixelRatio) + "px";
			ANCHOR.style.height					= String(__image.textureCellHeight/__image.pixelRatio) + "px";
			ANCHOR.style.opacity				= 0;
			ANCHOR.style.margin					= "0px";
			ANCHOR.style.padding				= "0px";
			ANCHOR.style.visibility				= "visible";
			ANCHOR.style.backfaceVisibility		= "hidden";
			ANCHOR.style.overflow				= "hidden";
			ANCHOR.style.backgroundColor		= "transparent";
			ANCHOR.style.transformStyle			= "preserve-3d";
			ANCHOR.style.webkitTransformStyle	= "preserve-3d";
			ANCHOR.style.transformOrigin		= "0% 0% 0px";
			ANCHOR.style.webkitTransformOrigin	= "0% 0% 0px";
			ANCHOR.style.transform				= "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
			ANCHOR.style.webkitTransformStyle	= "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
			ANCHOR.style.borderSpacing			= 0;
			ANCHOR.style.borderWidth			= 0;

			// Set ANCHOR background image
			ANCHOR.style.backgroundImage 		= "url(" + __image.hImage.src + ")";
			ANCHOR.style.backgroundPosition		= "0px 0px";
			ANCHOR.style.backgroundRepeat		= "no-repeat";
			ANCHOR.style.backgroundSize			= String(__image.hImage.naturalWidth/__image.pixelRatio) + "px " + String(__image.hImage.naturalHeight/__image.pixelRatio) + "px";
			ANCHOR.style.backgroundBlendMode	= "normal";
			ANCHOR.style.backgroundClip			= "border-box";
			ANCHOR.style.backgroundOrigin		= "border-box";

			ANCHOR = document.body.appendChild(ANCHOR);
			ANCHOR.setAttribute("ready", "true");

			if(href!="" && href.indexOf("http")!=-1)
			{
				ANCHOR.setAttribute("href", href);
				ANCHOR.setAttribute("target", "_blank");
			}

			ANCHOR = document.body.appendChild(ANCHOR);

			__ANCHOR = ANCHOR;
		}

		return ANCHOR;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function destroyInplaceHTML()
	{
		if(__ANCHOR) __ANCHOR.parentNode.removeChild(__ANCHOR);
		__ANCHOR=null;
	}
}

// ==================================================================================================================================
//	   ______                _____      ____________          __                      ___________
//	  / ____/___  _________ / ___/___  / / __/_  __/__  _  __/ /___  __________  ____/ / ____/ (_)___
//	 / /   / __ \/ ___/ __ \\__ \/ _ \/ / /_  / / / _ \| |/_/ __/ / / / ___/ _ \/ __  / /   / / / __ \
//	/ /___/ /_/ / /__/ /_/ /__/ /  __/ / __/ / / /  __/>  </ /_/ /_/ / /  /  __/ /_/ / /___/ / / /_/ /
//	\____/\____/\___/\____/____/\___/_/_/   /_/  \___/_/|_|\__/\__,_/_/   \___/\__,_/\____/_/_/ .___/
//	                                                                                         /_/
// ==================================================================================================================================

class CocoSelfTexturedClip : CocoClip
{
	// IMPORTANT //

	// Self-textured Clips have the ability to self-generate a texture.
	// You must ALWAYS assume that the generated image will take some
	// time to load either from the internet or from base64 data, so
	// we need to use double-buffering.

	public var InvalidTexture:Boolean;
	protected var buffer:CocoImage;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor()
	{
		buffer = null;
		InvalidTexture = true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		delete buffer;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function prepare(ctx:ICocoRenderContext, scene:CocoScene, zIndex:Integer)
	{
		InvalidTexture = false;
		super.prepare;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function paint(ctx:ICocoRenderContext, scene:CocoScene, parentClip:CocoClip, calcBoundingBox:Boolean, level:Integer)
	{
		// If the self-textured object is invalid, we call prepare() to regenerate the texture.
		if(InvalidTexture)
		{
			prepare(ctx,scene,this.__zIndex);
		}

		// If there is a worker buffer image available we will try to swap it with clip's __image.
		if(buffer)
		{
			// First chech if the worker buffer has render data.
			// That means that it has a valid texture.
			if(buffer.renderData)
			{
				// Delete the old image (to release texture from GPU)
				delete __image;

				// Swap images
				__image = buffer;

				// Make sure the worker buffer is null.
				buffer = null;
			}

			// The worker buffer does not have render data.
			// Check if the buffer's HTML Image has completed loading.
			else if(buffer.hImage.complete)
			{
				// OK, the HTML image is loaded. Now we need
				// to create the Texture and render data for it.
				buffer.renderData = ctx.prepareImage(buffer);

				if(ctx.getGLContext())
				{
					// Since the image is texturized and its copy exists
					// on the GPU, we can safely delete the HTML image
					delete buffer.hImage;
				}
			}
		}

		super.paint;
	}
}

// ==================================================================================================================================
//	   ______               ______          __  _________
//	  / ____/___  _________/_  __/__  _  __/ /_/ ____/ (_)___
//	 / /   / __ \/ ___/ __ \/ / / _ \| |/_/ __/ /   / / / __ \
//	/ /___/ /_/ / /__/ /_/ / / /  __/>  </ /_/ /___/ / / /_/ /
//	\____/\____/\___/\____/_/  \___/_/|_|\__/\____/_/_/ .___/
//	                                                 /_/
// ==================================================================================================================================

class CocoTextClip : CocoSelfTexturedClip
{
	private var m_Text:String;
	private var m_FontFamily:String;
	private var m_FontSizePixels:Integer;
	private var m_FontBold:Boolean;
	private var m_FontItalic:Boolean;
	private var m_FontUnderline:Boolean;
	private var m_FontColor:Color;
	private var m_TextHorizAlign:COCO_TEXT_ALIGN_ENUM;
	private var m_TextVertAlign:COCO_TEXT_ALIGN_ENUM;

	published property Text
	{
		function get():String 		{ return m_Text; }
		function set(v:String)		{ if(m_Text!=v) { m_Text = v; InvalidTexture = true; } }
	}

	published property FontFamily
	{
		function get():String 		{ return m_FontFamily; }
		function set(v:String)		{ if(m_FontFamily!=v) { m_FontFamily = v; InvalidTexture = true; } }
	}

	published property FontSizePixels
	{
		function get():Integer		{ return m_FontSizePixels; }
		function set(v:Integer)		{ if(m_FontSizePixels!=v) { m_FontSizePixels = v; InvalidTexture = true; } }
	}

	published property FontBold
	{
		function get():Boolean		{ return m_FontBold; }
		function set(v:Boolean)		{ if(m_FontBold!=v) { m_FontBold = v; InvalidTexture = true; } }
	}

	published property FontItalic
	{
		function get():Boolean		{ return m_FontItalic; }
		function set(v:Boolean)		{ if(m_FontItalic!=v) { m_FontItalic = v; InvalidTexture = true; } }
	}

	published property FontUnderline
	{
		function get():Boolean		{ return m_FontUnderline; }
		function set(v:Boolean)		{ if(m_FontUnderline!=v) { m_FontUnderline = v; InvalidTexture = true; } }
	}

	published property FontColor
	{
		function get():Color		{ return m_FontColor; }
		function set(v:Color)		{ if(m_FontColor!=v) { m_FontColor = v; InvalidTexture = true; } }
	}

	published property TextHorizAlign
	{
		function get():COCO_TEXT_ALIGN_ENUM		{ return m_TextHorizAlign; }
		function set(v:COCO_TEXT_ALIGN_ENUM)	{ if(m_TextHorizAlign!=v) { m_TextHorizAlign = v; InvalidTexture = true; } }
	}

	published property TextVertAlign
	{
		function get():COCO_TEXT_ALIGN_ENUM		{ return m_TextVertAlign; }
		function set(v:COCO_TEXT_ALIGN_ENUM)	{ if(m_TextVertAlign!=v) { m_TextVertAlign = v; InvalidTexture = true; } }
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor()
	{
		m_Text				= "";
		m_FontFamily		= "Helvetica";
		m_FontSizePixels 	= 15;
		m_FontBold			= false;
		m_FontItalic		= false;
		m_FontUnderline		= false;
		m_FontColor			= 0xff000000;
		m_TextHorizAlign	= COCO_TEXT_ALIGN_ENUM.TEXT_ALIGN_CENTER;
		m_TextVertAlign		= COCO_TEXT_ALIGN_ENUM.TEXT_ALIGN_CENTER;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function prepare(ctx:ICocoRenderContext, scene:CocoScene, zIndex:Integer)
	{
		delete buffer;

		var align:CocoHVAlign = CocoGraphics.AlignToCocoHVAlign(TextHorizAlign, TextVertAlign);
		var color:String = CocoGraphics.ColorToHtmlRGBA(FontColor);
    	var fontStyle:String = (FontItalic ? "italic" : "normal") + " normal " + (FontBold ? "bold " : "normal ") + String(FontSizePixels) + "px " + FontFamily;
    	var w:Integer = Math.max(1.0, Math.floor(__width));
    	var h:Integer = Math.max(1.0, Math.floor(__height));
    	var canvas:HTMLCanvasElement = CocoGraphics.NewCanvas(w, h, true);
		var c2d:CanvasRenderingContext2D = CanvasRenderingContext2D(canvas.getContext("2d"));

    	var f:CocoText = new CocoText();
    	f.str = Text;
    	f.indices.push(0);
    	f.mappings.push(0);
    	f.drawSimple(c2d, fontStyle, FontUnderline, color, 0, 0, w, h, align.horiz, align.vert);
		buffer = CocoGraphics.CocoImageFromHTMLCanvas(canvas, w, h);
		delete f;
		delete canvas;

		super.prepare;
	}
}

// ==================================================================================================================================
//	   ______                 __  ___           __   _________
//	  / ____/___  _________  /  |/  /___ ______/ /__/ ____/ (_)___
//	 / /   / __ \/ ___/ __ \/ /|_/ / __ `/ ___/ //_/ /   / / / __ \
//	/ /___/ /_/ / /__/ /_/ / /  / / /_/ (__  ) ,< / /___/ / / /_/ /
//	\____/\____/\___/\____/_/  /_/\__,_/____/_/|_|\____/_/_/ .___/
//	                                                      /_/
// ==================================================================================================================================

enum COCO_MASK_TYPE
{
	MASK_SHAPE = 0,
	MASK_IMAGE = 1
};

class CocoMaskClip : CocoSelfTexturedClip
{
	published var MaskType:COCO_MASK_TYPE;
	published var FillColor:Color;
	published var Invert:Boolean;

	public var Rectangles:Array<Float>;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor()
	{
		MaskType = COCO_MASK_TYPE.MASK_SHAPE;
		Invert = false;
		FillColor = 0xff000000;
		Rectangles = null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		delete Rectangles;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function paint(ctx:ICocoRenderContext, scene:CocoScene, parentClip:CocoClip, calcBoundingBox:Boolean, level:Integer)
	{
		//ctx.drawMaskBegin();
		super.paint;
		//ctx.drawMaskEnd(Invert);
	}
}
