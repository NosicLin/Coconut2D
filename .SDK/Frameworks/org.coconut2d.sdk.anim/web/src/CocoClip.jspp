"#export native"
"#export web"

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2014 www.coconut2D.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	   ______				  _________
//	  / ____/___  _________  / ____/ (_)___
//	 / /   / __ \/ ___/ __ \/ /   / / / __ \
//	/ /___/ /_/ / /__/ /_/ / /___/ / / /_/ /
//	\____/\____/\___/\____/\____/_/_/ .___/
//								   /_/
// ==================================================================================================================================

/**
 * CocoClip encapsulates reusable pieces of animation and are the basic animation mechanism in Coconut2D.
 * CocoClips have their own multiframe timeline that can contain interactive controls, sounds, and even
 * other CocoClip instances. At runtime a CocoClip can be either a container of other CocoClips refered
 * as "container clip" or it can animate a single image, refered as "primitive clip".
 *
 * The functionality of a CocoClip is rather straight forward. Each CocoClip receives as input a "transformation
 * matrix" from its parent clip and combines it (multiplies it) with its current timeline interpolation frame.
 * The resulting transformation matrix is used to either paint the image (if it is a primitive) or its children
 * clips (if it is a container).
 *
 * When a CocoClip needs to calculate the current timeline frame it uses time-interpolation; it simply finds
 * the previous and next KeyFrames for a given time and performs linear interpolation in order to calculate
 * the key transformation values (translation, rotation, scale, alpha, etc.).
 *
 * A CocoClip can be set to calculate its bounding rectanble or bounding box. That is the rectangle used to
 * fully encapsulate either its image (if it is a primitive) or its children (if it is a container). Bounding
 * boxes are used for hit-tests so that we can detect when a user clicks/touches a CocoClip. Bounding box
 * calculation is somewhat expensive because it involves multiplication of matrixes and vectors, so we only
 * do it when the animation engine requests it on the current cycle so that it is available on the next.
 * This actually means that there is a 16ms delay from the time a user places his finger on the screen
 * before we are able to respond to it.
 *
 * CocoClips can also animate "Sprite Animation Sequences" if they detect that the primitive image has
 * spritesheet information associated with it.
 *
 * Last but not least, CocoClip API offers several animation control functions such as gotoFrameByName
 * and gotoFrameByIndex that jump the animation to a specific keyframe or time label. This feature is
 * used for programmatically controlling your animations and games.
 *
 * @module CocoClip.jspp
 * @version 0.1
 * @author Elias Politakis <epolitakis@mobilefx.com>
 * @copyright www.coconut2D.org 2013-2014
 * @tutorial
 * @summary CocoClips encapsulate reusable pieces of animation
 * @description CocoClips encapsulate reusable pieces of animation
 */
class CocoClip
{
	public var __instanceName:String;
	public var __clipPath:String;
	public var __scene:CocoScene;
	public var __image:CocoImage;
	public var __symbolLoop:COCO_CLIP_SYMBOL_LOOP_ENUM;
	public var __children:Array<CocoClip>;
	public var __timeline:CocoTimeline;
	public var __parent:CocoClip;

	// Text
	public var text:String;
	public var textFontName:String;
	public var textFontSize:Integer;//pixels
	public var textHAlign:COCO_TEXT_ALIGN_ENUM;
	public var textVAlign:COCO_TEXT_ALIGN_ENUM;
	public var textMultiline:Boolean
	public var textTrimming:COCO_TEXT_TRIMMING_ENUM;
	public var textColor:String;
	public var textWidth:Integer;
	public var textHeight:Integer;

	// Animation Control Variables
	public var __currentTime:Time;
	public var __loopTime:Time;
	public var __loops:Integer;
	public var __currentFrame:CocoKeyFrame;
	public var __childWithMaxTimelineDuration:CocoClip;

	// Bounding Box & Hit Test
	public var __hasBoundingBox:Boolean;
	public var __vABS_TOP_LEFT:CocoVector;
	public var __vABS_TOP_RIGHT:CocoVector;
	public var __vABS_BOTTOM_LEFT:CocoVector;
	public var __vABS_BOTTOM_RIGHT:CocoVector;
	public var __vREL_TOP_LEFT:CocoVector;
	public var __vREL_TOP_RIGHT:CocoVector;
	public var __vREL_BOTTOM_LEFT:CocoVector;
	public var __vREL_BOTTOM_RIGHT:CocoVector;
	public var __vTemp:CocoVector;
	public var __mTemp:CocoMatrix;

	// References to objects we do not own (do not delete in destructor)
	private var __currentSequence:CocoSequence;
	private var __currentAudio:CocoAudio;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor(optional image:CocoImage)
	{
		__symbolLoop					= COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_CONTINUOUS;
		__timeline						= new CocoTimeline();
		__children						= new Array<CocoClip>;
		__parent						= null;
		__currentTime					= 0.0;
		__currentFrame					= null;
		__hasBoundingBox				= false;
		__vABS_TOP_LEFT					= new CocoVector();
		__vABS_TOP_RIGHT				= new CocoVector();
		__vABS_BOTTOM_LEFT				= new CocoVector();
		__vABS_BOTTOM_RIGHT				= new CocoVector();
		__vREL_TOP_LEFT					= new CocoVector();
		__vREL_TOP_RIGHT				= new CocoVector();
		__vREL_BOTTOM_LEFT				= new CocoVector();
		__vREL_BOTTOM_RIGHT				= new CocoVector();
		__vTemp							= new CocoVector();
		__mTemp							= new CocoMatrix();
		__childWithMaxTimelineDuration	= null;
		__currentSequence				= null;
		__currentAudio					= null;
		__clipPath						= "";

		__image = image;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		delete __image;
		delete __children;
		delete __timeline;
		delete __vABS_TOP_LEFT;
		delete __vABS_TOP_RIGHT;
		delete __vABS_BOTTOM_LEFT;
		delete __vABS_BOTTOM_RIGHT;
		delete __vREL_TOP_LEFT;
		delete __vREL_TOP_RIGHT;
		delete __vREL_BOTTOM_LEFT;
		delete __vREL_BOTTOM_RIGHT;
		delete __vTemp;
		delete __mTemp;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function prepare(scene:CocoScene)
	{
		__timeline.prepare(scene, this);
		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			__children[i].prepare(scene);
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Creates and assigns to a CocoClip a new texture image containing some text. This is a low-level
	 * text rendering function and should not be used directly.

	 * @returns void
	 * @param {!String} 					text 				- The text to draw
	 */
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function setText(text:String)
	{
		setText(text, textFontName, textFontSize, textHAlign, textVAlign, textMultiline, textTrimming, textColor, textWidth, textHeight);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/**
	 * Creates and assigns to a CocoClip a new texture image containing some text. This is a low-level
	 * text rendering function and should not be used directly.

	 * @returns void
	 * @param {!String} 					text 				- The text to draw
	 * @param {!String} 					fontName 			- The font name to use for drawing the text
	 * @param {!Integer} 					fontSizePixels		- The font size in pixels
	 * @param {!COCO_TEXT_ALIGN_ENUM} 		hAlign 				- Horizontal align of the text
	 * @param {!COCO_TEXT_ALIGN_ENUM} 		vAlign 				- Vertical align of the text
	 * @param {!Boolean} 					multiline 			- Text can be multilined
	 * @param {!COCO_TEXT_TRIMMING_ENUM}	trimming 			- Text trimming method
	 * @param {!CSSColor} 					CSSColor 			- Text color
	 * @param {!textRectWidth} 				textRectWidth 		- Surface width available for drawing the text
	 * @param {!textRectHeight} 			textRectHeight		- Surface height available for drawing the text
	 */
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function setText(text:String, fontName:String, fontSizePixels:Integer, hAlign:COCO_TEXT_ALIGN_ENUM, vAlign:COCO_TEXT_ALIGN_ENUM, multiline:Boolean, trimming:COCO_TEXT_TRIMMING_ENUM, CSSColor:String, textRectWidth:Integer, textRectHeight:Integer)
	{
		this.text			= text;
		this.textFontName   = fontName;
		this.textFontSize   = fontSizePixels;
		this.textHAlign     = hAlign;
		this.textVAlign     = vAlign;
		this.textMultiline  = multiline;
		this.textTrimming   = trimming;
		this.textColor      = CSSColor;
		this.textWidth      = textRectWidth;
		this.textHeight     = textRectHeight;

		delete __image;
		__image = graphics.createTextTexture(__scene, text, fontName, fontSizePixels, hAlign, vAlign, multiline, trimming, CSSColor, textRectWidth, textRectHeight);

	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function reset()
	{
		if(__currentFrame) delete __currentFrame;
		__currentFrame = null;
		__currentTime = 0.0;
		__timeline.reset();

		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			__children[i].reset();
		}
		if(__currentAudio) __currentAudio.reset();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function clear()
	{
		__children.clear();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function addChild(clipInstance:CocoClip) :CocoClip
	{
		if(!clipInstance) return null;
		if(!clipInstance.__instanceName) throw "Invalid instance name.";
		__children.push(clipInstance);
		normalize();
		clipInstance.__clipPath = (__clipPath ? __clipPath : __instanceName) + "/" + clipInstance.__instanceName;
		return clipInstance;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function removeChild(clipInstance:CocoClip) :CocoClip
	{
		if(!clipInstance) return null;
		var index:Integer = getChildIndex(clipInstance);
		if(index==-1) return null;
		__children.splice(index, 1);
		normalize();
		return clipInstance;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function normalize()
	{
		// Find clip with max timeline duration.
		__childWithMaxTimelineDuration = null;
		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			if(!__childWithMaxTimelineDuration)
			{
				__childWithMaxTimelineDuration = __children[i];
				continue;
			}
			if(__children[i].__timeline.__durationInTime > __childWithMaxTimelineDuration.__timeline.__durationInTime)
			{
				__childWithMaxTimelineDuration = __children[i];
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildByName(instanceName:String) :CocoClip
	{
		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			if(__children[i].__instanceName==instanceName)
			{
				return __children[i];
			}
		}
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildIndex(child:CocoClip) :Integer
	{
		if(child)
		{
			for(var i:Integer =__children.size()-1; i>=0; i--)
			{
				if(__children[i]==child)
				{
					return i;
				}
			}
		}
		return -1;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoFrameByName(LabelName:String, optional pause:Boolean) :Boolean
	{
		var Label:CocoTimeLabel = __timeline.findLabelByName(LabelName);
		if(!Label) return false;

		//trace("\ngotoFrameByName: clip=" + __clipPath + ", label=" + LabelName + ", pause=" + String(pause));

		return gotoFrameByIndex(Label.frameIndex, pause);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoFrameByIndex(FrameIndex:Integer, optional pause:Boolean) :Boolean
	{
		//trace("\ngotoFrameByIndex: clip=" + __clipPath + ", index=" + (FrameIndex==-1 ? "STOP_ON_CURRENT_FRAME" : String(FrameIndex)) + ", pause=" + String(pause));

		var clip:CocoClip;
		for (var i:Integer = __children.size() - 1; i >= 0; i--)
		{
			clip = __children[i];

			if(FrameIndex==COCO_STOP_ON_CURRENT_FRAME)
				FrameIndex = clip.__currentFrame ? clip.__currentFrame.frameIndex : 0;

			clip.__timeline.__paused = pause;
			clip.__timeline.__currentFrameIndex = -1;

			clip.__currentTime = Time(FrameIndex) * clip.__timeline.__singleFrameDurationTime;

			//trace("-> child: " + clip.__clipPath + ", from=" + (clip.__currentFrame ? String(clip.__currentFrame.frameIndex) : "0") + ", to=" + String((FrameIndex==-1 ? clip.__currentFrame.frameIndex : FrameIndex)) + ", time=" + clip.__currentTime.toFixed(2) + ", paused=" + String(clip.__timeline.__paused));
		}
		return true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function __advanceTime(parentClipsDuration:Time)
	{
		if(__timeline.__paused) return;
		__currentTime += engine.TICK_TIME;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function paint(gl:WebGLRenderingContext, scene:CocoScene, parentClip:CocoClip, calcBoundingBox:Boolean, level:Integer)
	{
		__scene = scene;

        // =============================================================================================================
		// Get touch event
        // =============================================================================================================
		var touchEvent:DeviceEvent = engine.getTouchEvent();
		if(touchEvent && touchEvent.type!="touchend" && touchEvent.type!="mouseup")
		{
			touchEvent = null;
		}

		// Calculate the parent timeline duration in time from its children (which are siblings to this clip)
		var parentClipsDuration:Time = parentClip ? parentClip.__childWithMaxTimelineDuration.__timeline.__durationInTime : this.__timeline.__singleFrameDurationTime;

        // =============================================================================================================
        // Combine with parent clip and interpolate
        // =============================================================================================================
		if(parentClip)
		{
			// Calculate this clip's LoopTime which is the projection of this clip's timeline to its parent's timeline.
			__loops = Math.floor(__currentTime / parentClipsDuration);
			__loopTime = __currentTime - (Time(__loops) * parentClipsDuration);

			// Calculate frameIndex from time.
			var frameIndex:Float = __loopTime / __timeline.__singleFrameDurationTime;

			// Interpolate
			if(__currentFrame)
				delete __currentFrame;
			__currentFrame = __timeline.interpolate(frameIndex);
			if(!__currentFrame) return;

			// Combine parent clip currentframe values with this clip's interpolated frame values.
			 __currentFrame.combine(parentClip.__currentFrame);

			// If current frame is not visible then we skip processing children.
			if(__currentFrame.alpha == 0 || !__currentFrame.visible)
			{
				// Propagate clip's timeline.
				__advanceTime(parentClipsDuration);
				return;
			}

			// If we need to handle an event or if our parent has asked us to
			// calc our bounding box **AND** there is an actual event waiting
			// then we set calcBoundingBox to true.
			calcBoundingBox = (__currentFrame.handleEvents || calcBoundingBox) && (touchEvent!=null);
		}

        // =============================================================================================================
		// RENDER!
        // =============================================================================================================
		if(__image)
		{
			__currentFrame.scaleX *= __image.__pixelRatioScale;
			__currentFrame.scaleY *= __image.__pixelRatioScale;
			__currentFrame.apply(scene.__modelViewMatrix);
			__currentFrame.scaleX /= __image.__pixelRatioScale;
			__currentFrame.scaleY /= __image.__pixelRatioScale;

			// Get sequence name, first from current clip and if not found from parent clip.
			var sequenceName:String = __currentFrame.spriteSequenceName;
			if(!sequenceName && parentClip && parentClip.__currentFrame) sequenceName = parentClip.__currentFrame.spriteSequenceName;

			// Check if we should change sprite animation sequence
			if(!sequenceName)
			{
				__currentSequence = null;
			}
			else if(!__currentSequence || __currentSequence.name!=sequenceName)
			{
				//trace("Loading sprite animation sequence: " + this.__clipPath + " -> " + sequenceName);
				__currentSequence = __image.getSequence(sequenceName);
				__currentSequence.sequenceStartTime = __currentTime;
			}

			if(__image.isSpriteSheet && __currentSequence)
			{
				// Render animation sequence.
				var sequenceFrameIndex:Integer = __timeline.__paused ? 0 : Math.floor((__currentTime-__currentSequence.sequenceStartTime) / (1000.0 / scene.__fps)) % __currentSequence.frames.size();
				var frame:Integer = __currentSequence.frames[sequenceFrameIndex];
				scene.drawFrame(gl, __image, frame, __currentFrame);
			}
			else
			{
				// Render a standard image.
				scene.drawFrame(gl, __image, 0, __currentFrame);
			}
		}
		else
		{
			// Render Children
			var childrenCound:Integer = __children.size();
			if(childrenCound>0)
			{
				var child:CocoClip;
				scene.__levelParents.push(this);
				if(__currentFrame) __currentFrame.apply(scene.__modelViewMatrix);
				for (var i:Integer = 0; i < childrenCound; i++)
				{
					scene.__modelViewMatrix.push();
					child = __children[i];
					child.paint(gl, scene, this, calcBoundingBox, level+1);
					scene.__modelViewMatrix.pop();
				}
				scene.__levelParents.pop();
			}
		}

		if(this!=scene.__root)
		{
	        // =============================================================================================================
			// Calculare bounding box
	        // =============================================================================================================
			if(calcBoundingBox)
			{
				// Calculate bounding box vertices
				if(__image)
					initBoundingBoxFromTexture(scene, __image.textureCellWidth / 2, __image.textureCellHeight / 2);
				else if(__children.size()>0)
					initBoundingBoxFromChildren(scene);
			}

	        // =============================================================================================================
			// Handle touch event
	        // =============================================================================================================
			if(calcBoundingBox && __currentFrame.handleEvents)
			{
				// Point in quad?
	   	        var x:Float = (touchEvent.__clientX - gl.canvas.width / 2.0) / scene.__view_scale;
				var y:Float = (touchEvent.__clientY - gl.canvas.height / 2.0) / scene.__view_scale;
				if(hitTest(x,y))
	   	        {
	   	        	engine.pushTouched(this);
	   	        	//drawBoundingBox(scene, gl);
	   	        }
			}

	        // =============================================================================================================
			// Execute KeyFrame
	        // =============================================================================================================
			if(!__timeline.__paused)
			{
				this.__parent = parentClip;

				if(__currentFrame.action)
				{
					//engine.__trace(scene, this, "@@ACTION");
					__currentFrame.action.call(scene);
				}

				if(__currentFrame.nextState)
				{
					//engine.__trace(scene, this, "@@NEXT_STATE");
					engine.setNextState(__currentFrame.nextState);
				}

				if(__currentFrame.audio)
				{
					//engine.__trace(scene, this, "@@AUDIO");
					__currentFrame.audio.tick();
				}

		        // =============================================================================================================
				// Audio Management (the trick here is not to reset a background sound when executing an action)
		        // =============================================================================================================
				if(__currentFrame.audio)
				{
					if(__currentAudio && ((__currentFrame.audio != __currentAudio) || (__currentAudio.loops!=0)))
						__currentAudio.reset();
					__currentAudio = __currentFrame.audio;
				}

				this.__parent = null;
			}

	        // =============================================================================================================
			// Tick audio
	        // =============================================================================================================
			if(__currentAudio)
			{
				__currentAudio.tick();
				if(__currentAudio.ended())
				{
					__currentAudio.reset();
					__currentAudio = null;
				}
			}
		}

		// =============================================================================================================
		// Propagate clip's timeline.
		// =============================================================================================================
		__advanceTime(parentClipsDuration);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function hitTest(wx:Float, wy:Float) :Boolean
	{
		return ((((wx - __vABS_TOP_LEFT.X) * (__vABS_TOP_RIGHT.Y - __vABS_TOP_LEFT.Y) - (__vABS_TOP_RIGHT.X - __vABS_TOP_LEFT.X) * (wy - __vABS_TOP_LEFT.Y)) * ((wx - __vABS_BOTTOM_RIGHT.X) * (__vABS_BOTTOM_LEFT.Y - __vABS_BOTTOM_RIGHT.Y) - (__vABS_BOTTOM_LEFT.X - __vABS_BOTTOM_RIGHT.X) * (wy - __vABS_BOTTOM_RIGHT.Y))) > 0
			&& (((wx - __vABS_TOP_RIGHT.X) * (__vABS_BOTTOM_RIGHT.Y - __vABS_TOP_RIGHT.Y) - (__vABS_BOTTOM_RIGHT.X - __vABS_TOP_RIGHT.X) * (wy - __vABS_TOP_RIGHT.Y)) * ((wx - __vABS_BOTTOM_LEFT.X) * (__vABS_TOP_LEFT.Y - __vABS_BOTTOM_LEFT.Y) - (__vABS_TOP_LEFT.X - __vABS_BOTTOM_LEFT.X) * (wy - __vABS_BOTTOM_LEFT.Y))) > 0);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function initBoundingBoxFromTexture(scene:CocoScene, W2:Float, H2:Float)
	{
		__mTemp.identity();

		__currentFrame.scaleX *= __image.__pixelRatioScale;
		__currentFrame.scaleY *= __image.__pixelRatioScale;
		__currentFrame.apply(__mTemp);
		__currentFrame.scaleX /= __image.__pixelRatioScale;
		__currentFrame.scaleY /= __image.__pixelRatioScale;

		//__currentFrame.apply(__mTemp);

		__vTemp.reset(-W2, -H2, 0, 1);
		__vREL_TOP_LEFT	= __mTemp.multiplyByVector(__vTemp);
		__vABS_TOP_LEFT	= scene.__modelViewMatrix.multiplyByVector(__vTemp);

		__vTemp.reset(W2, -H2, 0, 1);
		__vREL_TOP_RIGHT = __mTemp.multiplyByVector(__vTemp);
		__vABS_TOP_RIGHT = scene.__modelViewMatrix.multiplyByVector(__vTemp);

		__vTemp.reset(-W2, H2, 0, 1);
		__vREL_BOTTOM_LEFT = __mTemp.multiplyByVector(__vTemp);
		__vABS_BOTTOM_LEFT = scene.__modelViewMatrix.multiplyByVector(__vTemp);

		__vTemp.reset(W2, H2, 0, 1);
		__vREL_BOTTOM_RIGHT	= __mTemp.multiplyByVector(__vTemp);
		__vABS_BOTTOM_RIGHT = scene.__modelViewMatrix.multiplyByVector(__vTemp);

	    __hasBoundingBox = true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function initBoundingBoxFromChildren(scene:CocoScene)
	{
	    // This function calculates the bounding box of all our children.

	    __hasBoundingBox = false;

	    if(__children.size()==0)
	    	return;

	    __vREL_TOP_LEFT.X = 100000;
		__vREL_TOP_RIGHT.X = -100000;
	    __vREL_TOP_LEFT.Y = 100000;
	    __vREL_BOTTOM_LEFT.Y = -100000;

        var Child :CocoClip
        for (var i:Integer = 0, L:Integer = __children.size(); i < L; i++)
	    {
            Child = __children[i];
            if(Child.__hasBoundingBox)
            {
				if(Child.__vREL_TOP_LEFT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_TOP_LEFT.X;
				if(Child.__vREL_TOP_LEFT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_TOP_LEFT.X;
				if(Child.__vREL_TOP_LEFT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_TOP_LEFT.Y;
				if(Child.__vREL_TOP_LEFT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_TOP_LEFT.Y;

				if(Child.__vREL_TOP_RIGHT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_TOP_RIGHT.X;
				if(Child.__vREL_TOP_RIGHT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_TOP_RIGHT.X;
				if(Child.__vREL_TOP_RIGHT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_TOP_RIGHT.Y;
				if(Child.__vREL_TOP_RIGHT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_TOP_RIGHT.Y;

				if(Child.__vREL_BOTTOM_LEFT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_BOTTOM_LEFT.X;
				if(Child.__vREL_BOTTOM_LEFT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_BOTTOM_LEFT.X;
				if(Child.__vREL_BOTTOM_LEFT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_BOTTOM_LEFT.Y;
				if(Child.__vREL_BOTTOM_LEFT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_BOTTOM_LEFT.Y;

				if(Child.__vREL_BOTTOM_RIGHT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_BOTTOM_RIGHT.X;
				if(Child.__vREL_BOTTOM_RIGHT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_BOTTOM_RIGHT.X;
				if(Child.__vREL_BOTTOM_RIGHT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_BOTTOM_RIGHT.Y;
				if(Child.__vREL_BOTTOM_RIGHT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_BOTTOM_RIGHT.Y;
            }
	    }

	    __vREL_TOP_RIGHT.Y = __vREL_TOP_LEFT.Y;
	    __vREL_BOTTOM_LEFT.X = __vREL_TOP_LEFT.X;
	    __vREL_BOTTOM_RIGHT.X = __vREL_TOP_RIGHT.X;
	    __vREL_BOTTOM_RIGHT.Y = __vREL_BOTTOM_LEFT.Y;

	    __vABS_TOP_LEFT = scene.__modelViewMatrix.multiplyByVector(__vREL_TOP_LEFT);
	    __vABS_TOP_RIGHT = scene.__modelViewMatrix.multiplyByVector(__vREL_TOP_RIGHT);
	    __vABS_BOTTOM_LEFT = scene.__modelViewMatrix.multiplyByVector(__vREL_BOTTOM_LEFT);
	    __vABS_BOTTOM_RIGHT = scene.__modelViewMatrix.multiplyByVector(__vREL_BOTTOM_RIGHT);

		__mTemp.identity();

		__currentFrame.apply(__mTemp);

	    __vREL_TOP_LEFT = __mTemp.multiplyByVector(__vREL_TOP_LEFT);
	    __vREL_TOP_RIGHT = __mTemp.multiplyByVector(__vREL_TOP_RIGHT);
	    __vREL_BOTTOM_LEFT = __mTemp.multiplyByVector(__vREL_BOTTOM_LEFT);
	    __vREL_BOTTOM_RIGHT = __mTemp.multiplyByVector(__vREL_BOTTOM_RIGHT);

	    __hasBoundingBox = true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function drawBoundingBox(scene:CocoScene, gl:WebGLRenderingContext)
	{
		if(!__hasBoundingBox) return;

		gl.disableVertexAttribArray(scene.__glProgram.GLSLiTexCoords);
		gl.disableVertexAttribArray(scene.__glProgram.GLSLiVecCoords);

		gl.useProgram(scene.__boundingBoxProgram);
		gl.enableVertexAttribArray(scene.__boundingBoxProgram.GLSLiVec2Coords);

		gl.bindBuffer(gl.ARRAY_BUFFER, scene.__boundingBoxBuffer);
		gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array([__vABS_TOP_LEFT.X, __vABS_TOP_LEFT.Y, __vABS_TOP_RIGHT.X, __vABS_TOP_RIGHT.Y, __vABS_BOTTOM_RIGHT.X, __vABS_BOTTOM_RIGHT.Y, __vABS_BOTTOM_LEFT.X, __vABS_BOTTOM_LEFT.Y]));
		gl.vertexAttribPointer(scene.__boundingBoxProgram.GLSLiVec2Coords, 2, gl.FLOAT, false, 0, 0);
		scene.__projectionMatrix.update(gl, scene.__boundingBoxProgram.GLSLuProjMat);
		gl.drawArrays(gl.LINE_LOOP, 0, 4);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);

		gl.disableVertexAttribArray(scene.__boundingBoxProgram.GLSLiVec2Coords);
		gl.useProgram(scene.__glProgram);

		gl.enableVertexAttribArray(scene.__glProgram.GLSLiTexCoords);
		gl.enableVertexAttribArray(scene.__glProgram.GLSLiVecCoords);
	}
}
