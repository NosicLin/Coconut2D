"#export native";
"#export web";

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2014 www.coconut2D.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	   ______                _____
//	  / ____/___  _________ / ___/___  ____ ___  _____  ____  ________
//	 / /   / __ \/ ___/ __ \\__ \/ _ \/ __ `/ / / / _ \/ __ \/ ___/ _ \
//	/ /___/ /_/ / /__/ /_/ /__/ /  __/ /_/ / /_/ /  __/ / / / /__/  __/
//	\____/\____/\___/\____/____/\___/\__, /\__,_/\___/_/ /_/\___/\___/
//	                                   /_/
// ==================================================================================================================================

class CocoSequence
{
	public var name:String;
	public var frames:Array<Integer>;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor(name:String, framesArray:Array<Integer>)
	{
		this.name = name;
		this.frames = framesArray;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		delete frames;
	}
}

// ==================================================================================================================================
//	   ______                 ____                          _____ _ __    ___
//	  / ____/___  _________  /  _/___ ___  ____ _____ ____ / ___/(_) /_  / (_)___  ____ _
//	 / /   / __ \/ ___/ __ \ / // __ `__ \/ __ `/ __ `/ _ \\__ \/ / __ \/ / / __ \/ __ `/
//	/ /___/ /_/ / /__/ /_/ // // / / / / / /_/ / /_/ /  __/__/ / / /_/ / / / / / / /_/ /
//	\____/\____/\___/\____/___/_/ /_/ /_/\__,_/\__, /\___/____/_/_.___/_/_/_/ /_/\__, /
//	                                          /____/                            /____/
// ==================================================================================================================================

class CocoImageResolution
{
	public var url:String;
	public var pixelRatio:Float;
	public var textureWidth:Float;
	public var textureHeight:Float;
	public var textureScale:Float;
	public var tileWidth:Float;
	public var tileHeight:Float;
	public var tileMap:Int32Array;

	public function Constructor(url:String, pixelRatio:Float, textureWidth:Float, textureHeight:Float, textureScale:Float, tileWidth:Float, tileHeight:Float, tileMap:Int32Array)
	{
		this.url = url;
		this.pixelRatio = pixelRatio;
		this.textureWidth = textureWidth;
		this.textureHeight = textureHeight;
		this.textureScale = textureScale;
		this.tileWidth = tileWidth;
		this.tileHeight = tileHeight;
		this.tileMap = tileMap;
	}

	public function Destructor()
	{
		delete tileMap;
	}
}

// ==================================================================================================================================
//	   ______                 ____
//	  / ____/___  _________  /  _/___ ___  ____ _____ ____
//	 / /   / __ \/ ___/ __ \ / // __ `__ \/ __ `/ __ `/ _ \
//	/ /___/ /_/ / /__/ /_/ // // / / / / / /_/ / /_/ /  __/
//	\____/\____/\___/\____/___/_/ /_/ /_/\__,_/\__, /\___/
//	                                          /____/
// ==================================================================================================================================

class CocoImage
{
	public var symbolName:String;
	public var hImage:Image;

	public reference var scene:CocoScene;

	// Texture
	public var textureCellWidth:Float;
	public var textureCellHeight:Float;
	public var textureScale:Float;
	public var textureGrid:Float32Array;
	public var textureTileMap:Float32Array;
	public var color:Float32Array;
	public var texSize:Float32Array;
	public var isSpriteSheet:Boolean;

	// Sprite
	public var sequences:Array<CocoSequence>;

	// Skin
	public var skin:Float32Array;  // W1, W2, W3, H1, H2, H3

	// Tiled Layer
	public var tileWidth:Integer;
	public var tileHeight:Integer;
	public var tileMap:Int32Array;

	// Render
	public var renderData:ICocoImageRenderData;
	public var onLoadResizeWidth:Float;
	public var onLoadResizeHeight:Float;

	// Resolution Siblings
	public var baseUrl:String;
	public var viewOptimalWidth:Integer;
	public var viewOptimalHeight:Integer;
	public var viewSiblings:Array<CocoImageResolution>;
	public var pixelRatio:Float;
	public var scaleX:Float;
	public var scaleY:Float;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public static function createFromURL(url:String, optional resizeWidth:Float, optional resizeHeight:Float):CocoImage
	{
		var img:CocoImage = new CocoImage();
		img.textureCellWidth = 0;
		img.textureCellHeight = 0;
		img.textureScale = 1;
		img.pixelRatio = 1;
		img.tileWidth = 0;
		img.tileHeight = 0;
		img.tileMap = null;
		img.hImage = new Image();
		img.hImage.load(url, img);
		img.onLoadResizeWidth = resizeWidth;
		img.onLoadResizeHeight = resizeHeight;
		return img;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor()
	{
		scene				= null;
		renderData			= null;
		baseUrl				= "";
		color				= new Float32Array([1.0, 1.0, 1.0, 1.0]);
		hImage				= null;
		isSpriteSheet		= false;
		pixelRatio			= 1.0;
		scaleX				= 0.0;
		scaleY				= 0.0;
		sequences			= new Array<CocoSequence>;
		skin				= null;
		tileWidth			= 0;
		tileHeight			= 0;
		tileMap				= null;
		symbolName			= "";
		texSize				= new Float32Array([1.0, 1.0]);
		textureCellHeight	= 0;
		textureCellWidth	= 0;
		textureScale		= 1;
		textureGrid			= new Float32Array([0.0, 0.0]);
		textureGrid			= new Float32Array([0.0]);
		textureTileMap		= new Float32Array([0.0, 0.0]);
		viewOptimalHeight	= 0;
		viewOptimalWidth	= 0;
		onLoadResizeWidth	= 0;
		onLoadResizeHeight	= 0;
		viewSiblings		= new Array<CocoImageResolution>;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		scene = null;
		delete viewSiblings;
		delete sequences;
		delete textureGrid;
		delete textureTileMap;
		delete color;
		delete texSize;
		delete renderData;
		delete hImage;
		delete skin;
		delete tileMap;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function __error(hImage:Image):Boolean
	{
		return true; // Retry
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function __loaded(hImage:Image)
	{
		if(onLoadResizeWidth>0 || onLoadResizeHeight>0 || textureCellWidth==0 || textureCellHeight==0)
		{
			var w:Float = onLoadResizeWidth ? onLoadResizeWidth : hImage.naturalWidth;
			var h:Float = onLoadResizeHeight ? onLoadResizeHeight : hImage.naturalHeight;
			var canvas:HTMLCanvasElement = CocoGraphics.NewCanvas(w, h, engine.__ctx.getGLContext()!=null);
			var ctx:CanvasRenderingContext2D = CanvasRenderingContext2D(canvas.getContext("2d"));
			ctx.drawImage(hImage, 0, 0, hImage.naturalWidth, hImage.naturalHeight, 0, 0, w, h);
			delete hImage;
			onLoadResizeWidth = 0;
			onLoadResizeHeight = 0;
			this.createFromCanvas(canvas, w, h);
			delete canvas;
		}
		else
		{
			loaded();
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function createFromCanvas(canvas:HTMLCanvasElement, width:Float, height:Float)
	{
		createFromBase64(canvas.toDataURL("image/png"));
        textureCellWidth = Float(width);
        textureCellHeight = Float(height);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function createFromBase64(url:String, optional width:Float, optional height:Float)
	{
		delete hImage;
        hImage = new Image();
        hImage.load(url, this);
        textureCellWidth = width ? width : hImage.width;
        textureCellHeight = height ? height : hImage.height;
        textureGrid = new Float32Array([0,0]);
        if(hImage.complete)
			this.renderData = engine.__ctx.prepareImage(this);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function addResolution(sibling:CocoImageResolution) :CocoImageResolution
	{
		viewSiblings.push(sibling);
		return sibling;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function addSequence(sequence:CocoSequence) :CocoSequence
	{
		if(!sequence) return null;
		if(getSequence(sequence.name)) throw "Sequence " + sequence.name + " already exists.";
		sequences.push(sequence);
		isSpriteSheet = true;
		return sequence;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getSequence(name:String) :CocoSequence
	{
		for (var i:Integer = sequences.size() - 1; i >= 0; i--)
		{
			if(sequences[i].name == name)
				return sequences[i];
		}
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function load()
	{
		var sibling:CocoImageResolution;

		// For mobile browsers we use mdpi
		if(engine.device.isHTML5Browser)
		{
			for(var j:Integer = 0; j<viewSiblings.size(); j++)
			{
				sibling = viewSiblings[j];
				if(sibling.pixelRatio==1)
				{
					hImage = new Image();
					hImage.load(baseUrl + sibling.url);
					textureCellWidth = sibling.textureWidth;
					textureCellHeight = sibling.textureHeight;
					textureScale = sibling.textureScale;
					pixelRatio = sibling.pixelRatio;
					tileWidth = sibling.tileWidth;
					tileHeight = sibling.tileHeight;
					tileMap = sibling.tileMap;
					break;
				}
			}
		}
		else if(scene.__view_width && scene.__view_height)
		{
			var tollerance:Float = 1.20;
			var w:Float = tollerance * Float(viewOptimalWidth) * scene.__view_scale;
			var h:Float = tollerance * Float(viewOptimalHeight) * scene.__view_scale;
			for(var j:Integer = 0; j<viewSiblings.size(); j++)
			{
				sibling = viewSiblings[j];
				if(sibling.textureWidth>=w && sibling.textureHeight>=h)
				{
					hImage = new Image();
					hImage.load(baseUrl + sibling.url);
					textureCellWidth = sibling.textureWidth;
					textureCellHeight = sibling.textureHeight;
					textureScale = sibling.textureScale;
					pixelRatio = sibling.pixelRatio;
					tileWidth = sibling.tileWidth;
					tileHeight = sibling.tileHeight;
					tileMap = sibling.tileMap;
					break;
				}
			}
		}

		// Fallback to best image
		if(!hImage)
		{
			sibling = viewSiblings[viewSiblings.size()-1];
			if(sibling)
			{
				hImage = new Image();
				hImage.load(baseUrl + sibling.url);
				textureCellWidth = sibling.textureWidth;
				textureCellHeight = sibling.textureHeight;
				textureScale = sibling.textureScale;
				pixelRatio = sibling.pixelRatio;
				tileWidth = sibling.tileWidth;
				tileHeight = sibling.tileHeight;
				tileMap = sibling.tileMap;
			}
		}

		//if(hImage)
		//	trace("Loading image " + hImage.src);

		loaded();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function loaded():Boolean
	{
		if(renderData) return true;
		if(!hImage || !hImage.complete) return false;
		renderData = engine.__ctx.prepareImage(this);

		// On WebGL we can safely delete the image to save memory.
		if(isSpriteSheet && engine.__ctx.getGLContext()!=null)
			 delete hImage;

		return true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function unload()
	{
		delete hImage;
	}
}
