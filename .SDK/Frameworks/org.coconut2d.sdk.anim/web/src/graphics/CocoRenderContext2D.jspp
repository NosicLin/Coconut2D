"#export native";
"#export web";

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2014 www.coconut2D.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	    __________                 ____                 __          ______            __            __
//	   /  _/ ____/___  _________  / __ \___  ____  ____/ /__  _____/ ____/___  ____  / /____  _  __/ /_
//	   / // /   / __ \/ ___/ __ \/ /_/ / _ \/ __ \/ __  / _ \/ ___/ /   / __ \/ __ \/ __/ _ \| |/_/ __/
//	 _/ // /___/ /_/ / /__/ /_/ / _, _/  __/ / / / /_/ /  __/ /  / /___/ /_/ / / / / /_/  __/>  </ /_
//	/___/\____/\____/\___/\____/_/ |_|\___/_/ /_/\__,_/\___/_/   \____/\____/_/ /_/\__/\___/_/|_|\__/
//
// ==================================================================================================================================

class CocoRenderContext2D implements ICocoRenderContext
{
	// Canvas 2D Rendering Context
	private reference var c2d:CanvasRenderingContext2D;

	// Matrix
	private var __modelViewMatrix:CocoMatrix;
	private var __projectionMatrix:CocoMatrix;

	// CSS3 + HTML5 Rendering
	private var __css3:Boolean;

	///////////////////////////////////////////////////////////////////////////////////////////////
 	public function Constructor(ctx:CanvasRenderingContext2D, css3:Boolean)
 	{
 		__css3 = css3;
 		if(css3)
 		{
 			ctx.canvas.style.display="none";
 		}

 		c2d = ctx;

 		c2d.globalCompositeOperation="source-atop";

		ctx.imageSmoothingEnabled       = false;
		ctx.mozImageSmoothingEnabled    = false;
		ctx.oImageSmoothingEnabled      = false;
		ctx.webkitImageSmoothingEnabled = false;

		// set the size of the drawingBuffer
		c2d.canvas.width 		= Math.round(engine.device.screenWidth * engine.device.pixelRatio);
		c2d.canvas.height 		= Math.round(engine.device.screenHeight * engine.device.pixelRatio);

		// set the display size of the canvas
		c2d.canvas.style.width 	= String(engine.device.screenWidth)  + 'px';
		c2d.canvas.style.height = String(engine.device.screenHeight) + 'px';

		c2d.scale(engine.device.pixelRatio, engine.device.pixelRatio);

 		__modelViewMatrix = new CocoMatrix();
		__projectionMatrix = new CocoMatrix();
 	}

	///////////////////////////////////////////////////////////////////////////////////////////////
 	public function Destructor()
 	{
 		delete __modelViewMatrix;
 		delete __projectionMatrix;
 	}

 	///////////////////////////////////////////////////////////////////////////////////////////////
	public function getGLContext():WebGLRenderingContext				{ return null; }
	public function get2DContext():CanvasRenderingContext2D				{ return c2d; }
	public function getDisplayWidth():Float								{ return c2d.canvas.width / engine.device.pixelRatio; }
	public function getDisplayHeight():Float							{ return c2d.canvas.height / engine.device.pixelRatio; }
	public function getBufferWidth():Float								{ return c2d.canvas.width; }
	public function getBufferHeight():Float								{ return c2d.canvas.height; }
	public function getModelViewMatrix():CocoMatrix						{ return __modelViewMatrix; }
	public function getProjectionMatrix():CocoMatrix					{ return __projectionMatrix; }
	public function hide()												{ c2d.canvas.style.visibility="hidden"; }
	public function show()												{ c2d.canvas.style.visibility="visible"; }
	public function ready():Boolean										{ return true; }

	///////////////////////////////////////////////////////////////////////////////////////////////
 	public function flush()
 	{
 	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function cls()
	{
		__modelViewMatrix.identity();
		c2d.setTransform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
		c2d.fillStyle = "#ffffff";
		c2d.fillRect(0.0, 0.0, getDisplayWidth(), getDisplayHeight());
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function clip(x:Float, y:Float, w:Float, h:Float)
	{
		try
		{
			c2d.rect(x,y,w,h);
			c2d.clip();
		}
		catch(e)
		{
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function prepare(viewScale:Float)
	{
		clip(0,0,0,0);

		// set the display size of the canvas.
		c2d.canvas.style.width 	= String(engine.device.screenWidth) + "px";
		c2d.canvas.style.height = String(engine.device.screenHeight) + "px";

		// set the size of the drawingBuffer
		c2d.canvas.width 		= Math.round(engine.device.screenWidth * engine.device.pixelRatio);
		c2d.canvas.height 		= Math.round(engine.device.screenHeight * engine.device.pixelRatio);

		c2d.setTransform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
		c2d.scale(engine.device.pixelRatio, engine.device.pixelRatio);

		__projectionMatrix.identity();
		__projectionMatrix.translate(getBufferWidth()/2.0, getBufferHeight()/2.0);
		__projectionMatrix.scale(viewScale*engine.device.pixelRatio, viewScale*engine.device.pixelRatio);

		__modelViewMatrix.identity();

		engine.device.report();
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function prepareImage(img:CocoImage):ICocoImageRenderData
	{
		return new CocoImageRenderData2D();
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function prepareClip(clip:CocoClip)
	{
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function apply(clip:CocoClip, keyFrame:CocoKeyFrame, matrix:CocoMatrix)
	{
		if(!clip || !keyFrame || !matrix) return;

	 	if(keyFrame.x!=0 || keyFrame.y!=0)	 			matrix.translate(keyFrame.x, keyFrame.y);
	 	if(keyFrame.scaleX!=1 ||keyFrame.scaleY!=1) 	matrix.scale(keyFrame.scaleX, keyFrame.scaleY);
	 	if(keyFrame.rotation!=0) 						matrix.rotateZ(keyFrame.rotation * RADIANS);
	 	if(keyFrame.pivotX!=0 || keyFrame.pivotY!=0) 	matrix.translate(-keyFrame.pivotX, -keyFrame.pivotY);

		// This is used for in-place HTML5 DIVs that we inject in order to by-pass popup blockers for Facebook/Twitter
		if(clip.__ANCHOR && matrix==__modelViewMatrix)
		{
			clip.__ANCHOR.style.opacity = keyFrame.visible ? keyFrame.alpha : 0;

			var m:CocoMatrix = new CocoMatrix(__modelViewMatrix);
			m.scale(clip.__image.textureScale, clip.__image.textureScale);
			m.translate(-(clip.__image.textureCellWidth/clip.__image.pixelRatio)/2, -(clip.__image.textureCellHeight/clip.__image.pixelRatio)/2);
			m = __projectionMatrix.multiplyByMatrix(m);
			m.__m.rc34 = clip.__zIndex;
			clip.__ANCHOR.style.webkitTransform = clip.__ANCHOR.style.transform = m.toCSS3D(true);
		}

		// This is used in HTML5 CSS3 Mode
	 	if(__css3 && matrix==__modelViewMatrix)
	 	{
	 		var DIV:HTMLElement = document.getElementById(clip.__uniqueID);
	 		if(DIV)
	 		{
				DIV.style.opacity = DIV.getAttribute("ready")=="true" && keyFrame.visible ? keyFrame.alpha : 0;
				if(DIV.style.opacity==0)
				{
					DIV.parentNode.removeChild(DIV);
				}
				else
				{
					var m:CocoMatrix = new CocoMatrix(__modelViewMatrix);
					m.scale(clip.__image.textureScale, clip.__image.textureScale);
					m.translate(-(clip.__image.textureCellWidth/clip.__image.pixelRatio)/2, -(clip.__image.textureCellHeight/clip.__image.pixelRatio)/2);
					m = __projectionMatrix.multiplyByMatrix(m);
					m.__m.rc34 = clip.__zIndex;
					var tm:String = m.toCSS3D(true);// + " translateZ(" + String(clip.__zIndex) + ")";
					if(DIV.style.transform != tm)
					{
						DIV.style.webkitTransform = DIV.style.transform = tm;
					}
				}
	 		}
	 		if((!keyFrame.visible || keyFrame.alpha==0) && clip.__children.size()>0)
	 		{
	 			hideClipCanvas(clip);
	 		}
	 	}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	private function hideClipCanvas(clip:CocoClip)
	{
		for(var i:Integer=clip.__children.size()-1; i>=0; i--)
		{
			var DIV:HTMLElement = document.getElementById(clip.__children[i].__uniqueID);
			if(DIV) DIV.parentNode.removeChild(DIV);
			hideClipCanvas(clip.__children[i]);
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function drawFrame(scene:CocoScene, clip:CocoClip, image:CocoImage, keyFrame:CocoKeyFrame, textureIndex:Integer)
	{
		// ===================================================
		// Using HTML5 CSS3 technique
		// ===================================================

		if(!image || !image.hImage) return;

		if(__css3)
		{
			var DIV:HTMLElement = document.getElementById(clip.__uniqueID);

			if(!DIV)
			{
				DIV = document.createElement("div");
				DIV.id = clip.__uniqueID;
				DIV.setAttribute("instanceName", clip.__instanceName);

				DIV.style.position				= "absolute";
				DIV.style.top					= "0px";
				DIV.style.left					= "0px";
				DIV.style.width					= String(image.textureCellWidth/image.pixelRatio) + "px";
				DIV.style.height				= String(image.textureCellHeight/image.pixelRatio) + "px";
				DIV.style.opacity				= 0;
				DIV.style.margin				= "0px";
				DIV.style.padding				= "0px";
				DIV.style.visibility			= "visible";
				DIV.style.backfaceVisibility	= "hidden";
				DIV.style.overflow				= "hidden";
				DIV.style.backgroundColor		= "transparent";
				DIV.style.transformStyle		= "preserve-3d";
				DIV.style.webkitTransformStyle	= "preserve-3d";
				DIV.style.transformOrigin		= "0% 0% 0px";
				DIV.style.webkitTransformOrigin	= "0% 0% 0px";
				DIV.style.transform				= "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
				DIV.style.webkitTransformStyle	= "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
				DIV.style.borderSpacing			= 0;
				DIV.style.borderWidth			= 0;

				// If pointer events are disabled (recommended) then you won't
				// be able to mix HTML5 elements and expect to receive events.
				//DIV.style.pointerEvents			= "none";

				// Set DIV background image
				DIV.style.backgroundImage 		= "url(" + image.hImage.src + ")";
				DIV.style.backgroundPosition	= "0px 0px";
				DIV.style.backgroundRepeat		= "no-repeat";
				DIV.style.backgroundSize		= String(image.hImage.naturalWidth/image.pixelRatio) + "px " + String(image.hImage.naturalHeight/image.pixelRatio) + "px";
				DIV.style.backgroundBlendMode	= "normal";
				//DIV.style.backgroundAttachment	= "fixed";
				DIV.style.backgroundClip		= "border-box";
				DIV.style.backgroundOrigin		= "border-box";

				DIV = document.body.appendChild(DIV);
				DIV.setAttribute("ready", "true");
			}

			if(DIV.style.backgroundImage != "url(" + image.hImage.src + ")")
				DIV.style.backgroundImage = "url(" + image.hImage.src + ")";

			// Spritesheet Animation in pure HTML5 with CSS3!!
			var tx:Float = -(image.textureGrid[textureIndex * 2 + 1] * image.textureCellWidth/image.pixelRatio);
			var ty:Float = -(image.textureGrid[textureIndex * 2 + 0] * image.textureCellHeight/image.pixelRatio);
			DIV.style.backgroundPosition	= String(tx) + "px " + String(ty) + "px";
		}

		// ===================================================
		// Using a single HTML5 Canvas 2D Context
		// ===================================================
		else
		{
			if(keyFrame.alpha==0 || !keyFrame.visible) return;

			c2d.save();

			// Initialize Canvas transformation from Projection Matrix
			c2d.setTransform(__projectionMatrix.__m.rc11,
							 __projectionMatrix.__m.rc12,
							 __projectionMatrix.__m.rc21,
							 __projectionMatrix.__m.rc22,
							 __projectionMatrix.__m.rc41,
							 __projectionMatrix.__m.rc42);

			// Load Model View Matrix
			c2d.transform(__modelViewMatrix.__m.rc11,
						  __modelViewMatrix.__m.rc12,
						  __modelViewMatrix.__m.rc21,
						  __modelViewMatrix.__m.rc22,
						  Math.floor(__modelViewMatrix.__m.rc41),
						  Math.floor(__modelViewMatrix.__m.rc42));

			// Sprite textures might need additional scaling
			if(image.textureScale>0 && image.textureScale!=1.0)
			{
				c2d.scale(image.textureScale, image.textureScale);
			}

			// Scale for image pixel ratio
			if(image.pixelRatio!=1)
			{
				c2d.scale(1/image.pixelRatio, 1/image.pixelRatio);
			}

			// Calculate image copy rectangles
			var sw:Float = Math.floor( image.textureCellWidth															);
			var sh:Float = Math.floor( image.textureCellHeight				                                        	);
			var sx:Float = Math.floor( ((keyFrame.flipH ? 1.0 : 0.0) + image.textureGrid[textureIndex * 2 + 1]) * sw   	);
			var sy:Float = Math.floor( ((keyFrame.flipV ? 1.0 : 0.0) + image.textureGrid[textureIndex * 2 + 0]) * sh   	);
			var dx:Float = Math.floor( -sw / 2.0                                                                       	);
			var dy:Float = Math.floor( -sh / 2.0                                                                       	);
			var dw:Float = Math.floor( sw                                                                              	);
			var dh:Float = Math.floor( sh                                                                              	);

			// Set global alpha
			c2d.globalAlpha = keyFrame.alpha;

			// Some mobile browsers produce DOM errors if parameters are out of bounds.
			try
			{
				if(sx >= 0 && sy >= 0 && sw > 0 && sh > 0 && sx + sw <= image.hImage.naturalWidth && sy + sh <= image.hImage.naturalHeight && sx + sw > 0 && sy + sh > 0)
					c2d.drawImage(image.hImage, sx, sy, sw, sh, dx, dy, dw, dh);
			}
			catch(e)
			{
				trace("ERROR: c2d.drawImage()");
			}

			c2d.restore();
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function drawMaskBegin()
	{
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function drawMaskEnd(invert:Boolean)
	{
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function drawBoundingBox(clip:CocoClip)
	{
	}
}
