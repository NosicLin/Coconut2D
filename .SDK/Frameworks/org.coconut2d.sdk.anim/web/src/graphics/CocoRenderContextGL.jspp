"#export native";
"#export web";

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2014 www.coconut2D.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	   ______                 ____                 __          ______            __            __  ________
//	  / ____/___  _________  / __ \___  ____  ____/ /__  _____/ ____/___  ____  / /____  _  __/ /_/ ____/ /
//	 / /   / __ \/ ___/ __ \/ /_/ / _ \/ __ \/ __  / _ \/ ___/ /   / __ \/ __ \/ __/ _ \| |/_/ __/ / __/ /
//	/ /___/ /_/ / /__/ /_/ / _, _/  __/ / / / /_/ /  __/ /  / /___/ /_/ / / / / /_/  __/>  </ /_/ /_/ / /___
//	\____/\____/\___/\____/_/ |_|\___/_/ /_/\__,_/\___/_/   \____/\____/_/ /_/\__/\___/_/|_|\__/\____/_____/
//
// ==================================================================================================================================

class CocoRenderContextGL implements ICocoRenderContext
{
	// WebGL Context
	private reference var gl:WebGLRenderingContext;

	// Matrix
	private var __modelViewMatrix:CocoMatrix;
	private var __projectionMatrix:CocoMatrix;
	private var __projectionMatrix2D:CocoMatrix;
	private var __viewportVector:CocoVector;

	private var maskDraw:Boolean;

	// Shaders
	private reference var activeShader:CocoShaderCommon;
	private var shaderSimple:Array<CocoShaderSimple>;
	private var shaderSimpleWithAlpha:Array<CocoShaderSimpleWithAlpha>;
	private var shaderSaturationWithAlpha:Array<CocoShaderSaturationWithAlpha>;
	private var shaderParallaxHor:Array<CocoShaderParallaxHor>;
	private var shaderBoundingBox:CocoShaderBoundingBox;

	///////////////////////////////////////////////////////////////////////////////////////////////
 	public function Constructor(ctx:WebGLRenderingContext)
 	{
 		gl = ctx;

		// set the size of the drawingBuffer
		gl.canvas.width 		= Math.round(engine.device.screenWidth * engine.device.pixelRatio);
		gl.canvas.height 		= Math.round(engine.device.screenHeight * engine.device.pixelRatio);

		// set the display size of the canvas
		gl.canvas.style.width 	= String(engine.device.screenWidth)  + 'px';
		gl.canvas.style.height 	= String(engine.device.screenHeight) + 'px';

		__modelViewMatrix = new CocoMatrix();
		__projectionMatrix = new CocoMatrix();
		__projectionMatrix2D = new CocoMatrix();
		__viewportVector = new CocoVector();

		maskDraw = false;

		activeShader = null;

		shaderSimple = new Array<CocoShaderSimple>();
		shaderSimple.push(new CocoShaderSimple());
		shaderSimple.push(new CocoShaderSimple(true));

		shaderSimpleWithAlpha = new Array<CocoShaderSimpleWithAlpha>();
		shaderSimpleWithAlpha.push(new CocoShaderSimpleWithAlpha());
		shaderSimpleWithAlpha.push(new CocoShaderSimpleWithAlpha(true));

		shaderSaturationWithAlpha = new Array<CocoShaderSaturationWithAlpha>();
		shaderSaturationWithAlpha.push(new CocoShaderSaturationWithAlpha());
		shaderSaturationWithAlpha.push(new CocoShaderSaturationWithAlpha(true));

		shaderParallaxHor = new Array<CocoShaderParallaxHor>();
		shaderParallaxHor.push(new CocoShaderParallaxHor());
		shaderParallaxHor.push(new CocoShaderParallaxHor(true));

		shaderBoundingBox = new CocoShaderBoundingBox();
 	}

	///////////////////////////////////////////////////////////////////////////////////////////////
 	public function Destructor()
 	{
		delete __modelViewMatrix;
		delete __projectionMatrix;
		delete __projectionMatrix2D;
		delete __viewportVector;
		delete shaderSimple;
		delete shaderSimpleWithAlpha;
		delete shaderSaturationWithAlpha;
		delete shaderParallaxHor;
		delete shaderBoundingBox;
 	}

 	///////////////////////////////////////////////////////////////////////////////////////////////
 	public function getName():String									{ return "WebGL"; };
	public function getGLContext():WebGLRenderingContext				{ return gl; }
	public function get2DContext():CanvasRenderingContext2D				{ return null; }
	public function getDisplayWidth():Float								{ return getBufferWidth() / engine.device.pixelRatio; }
	public function getDisplayHeight():Float							{ return getBufferHeight() / engine.device.pixelRatio; }
	public function getBufferWidth():Float								{ return gl.canvas.width; }
	public function getBufferHeight():Float								{ return gl.canvas.height; }
	public function getModelViewMatrix():CocoMatrix						{ return __modelViewMatrix; }
	public function getProjectionMatrix():CocoMatrix					{ return __projectionMatrix; }
	public function hide()												{ gl.canvas.style.visibility="hidden"; }
	public function show()												{ gl.canvas.style.visibility="visible"; }
	public function ready():Boolean										{ return true; }
	public function getCanvas():HTMLCanvasElement						{ return gl.canvas; }

	///////////////////////////////////////////////////////////////////////////////////////////////
 	public function flush()
 	{
 	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function apply(clip:CocoClip, F:CocoKeyFrame, matrix:CocoMatrix)
	{
	 	if(!clip || !F || !matrix) return;

	 	if(F.x!=0 || F.y!=0) 			matrix.translate(F.x, F.y);
	 	if(F.scaleX!=1 ||F.scaleY!=1) 	matrix.scale(F.scaleX, F.scaleY);
	 	if(F.rotation!=0) 				matrix.rotateZ(F.rotation * RADIANS);
	 	if(F.pivotX!=0 || F.pivotY!=0) 	matrix.translate(-F.pivotX, -F.pivotY);

		if(clip.__ANCHOR && matrix==__modelViewMatrix)
		{
			clip.__ANCHOR.style.opacity = F.visible ? F.alpha : 0;

			var m:CocoMatrix = new CocoMatrix(__modelViewMatrix);
			m.scale(clip.__image.textureScale, clip.__image.textureScale);
			m.translate(-(clip.__image.textureCellWidth/clip.__image.pixelRatio)/2, -(clip.__image.textureCellHeight/clip.__image.pixelRatio)/2);
			m = __projectionMatrix2D.multiplyByMatrix(m);
			m.__m.rc34 = clip.__zIndex;
			clip.__ANCHOR.style.zIndex = clip.__zIndex;
			clip.__ANCHOR.style.webkitTransform = clip.__ANCHOR.style.transform = m.toCSS3D(true);
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function cls()
	{
		__modelViewMatrix.identity();
		gl.clearColor(0,0,0,1);
 		gl.clear(gl.COLOR_BUFFER_BIT);
 		gl.stencilMask(0x00);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	// Clip against physical pixels
	public function clip(x:Float, y:Float, w:Float, h:Float)
	{
		if(!(engine.device.isNative && engine.device.isIOS))
		{
			gl.enable(gl.SCISSOR_TEST);
			gl.scissor(x*engine.device.pixelRatio, y*engine.device.pixelRatio, w*engine.device.pixelRatio, h*engine.device.pixelRatio);
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function prepare(viewScale:Float)
	{
		// set the display size of the canvas.
		gl.canvas.style.width 	= String(engine.device.screenWidth) + "px";
		gl.canvas.style.height 	= String(engine.device.screenHeight) + "px";

		// set the size of the drawingBuffer
		gl.canvas.width 		= Math.round(engine.device.screenWidth * engine.device.pixelRatio);
		gl.canvas.height 		= Math.round(engine.device.screenHeight * engine.device.pixelRatio);

		// Set OpenGL Flags
		gl.enable(gl.STENCIL_TEST);
		gl.stencilFunc(gl.EQUAL, 0, 0xFF);
		gl.stencilMask(0x00);
		gl.stencilOp(gl.REPLACE, gl.KEEP, gl.KEEP);
		gl.disable(gl.DEPTH_TEST);
		gl.disable(gl.CULL_FACE);

		gl.pixelStorei(gl.UNPACK_ALIGNMENT,1);
		gl.pixelStorei(gl.PACK_ALIGNMENT,1);

		// Set Alpha Blending Mode
		gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
		gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.enable(gl.BLEND);

		// Prepare orthographic projection matrix
		if(window.deviceRotation)
		{
			var c:Float = Math.cos(window.deviceRotation);
			var s:Float = Math.sin(window.deviceRotation);
			var orthoWidth:Float = Math.abs(c * Float(getBufferWidth()) + s * Float(getBufferHeight()));
			var orthoHeight:Float = Math.abs(-s * Float(getBufferWidth()) + c * Float(getBufferHeight()));
			__projectionMatrix.ortho(-orthoWidth / 2.0, orthoWidth / 2.0, orthoHeight / 2.0,  -orthoHeight / 2.0, -1.0, 1.0);
			__projectionMatrix.rotateZ(-window.deviceRotation);
			__projectionMatrix.scale(viewScale*engine.device.pixelRatio, viewScale*engine.device.pixelRatio);
		}
		else
		{
			gl.viewport(0, 0, getBufferWidth(), getBufferHeight());
			__projectionMatrix.ortho(-getBufferWidth()/2.0, getBufferWidth()/2.0, getBufferHeight()/2.0, -getBufferHeight()/2.0, -1.0, 1.0);
			__projectionMatrix.scale(viewScale*engine.device.pixelRatio, viewScale*engine.device.pixelRatio);

			__projectionMatrix2D.identity();
			__projectionMatrix2D.translate(getDisplayWidth()/2.0, getDisplayHeight()/2.0);
			__projectionMatrix2D.scale(viewScale, viewScale);
		}

		// Initialize Model View Matrix
		__modelViewMatrix.identity();

		// Initialize Viewport Vector
		__viewportVector.reset(-(Float(getBufferWidth()) / 2.0) / viewScale, Float(getBufferWidth()) / 2.0 / viewScale, Float(getBufferHeight()) / 2.0 / viewScale, -(Float(getBufferHeight()) / 2.0 / viewScale));

		// Initialize Shaders
		shaderBoundingBox.initialize(gl, __projectionMatrix);
		shaderSimple[0].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderSimple[1].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderSimpleWithAlpha[0].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderSimpleWithAlpha[1].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderSaturationWithAlpha[0].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderSaturationWithAlpha[1].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderParallaxHor[0].initialize(gl, __projectionMatrix, __modelViewMatrix, __viewportVector);
		shaderParallaxHor[1].initialize(gl, __projectionMatrix, __modelViewMatrix, __viewportVector);

		// Set Active Shader
		activeShader = shaderSimple[0];
		activeShader.begin(gl);

		engine.device.report();
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function prepareImage(img:CocoImage):ICocoImageRenderData
	{
		if(!img || !img.hImage)
			return null;

		// Create an Image Rendering Data structure.
		var data:CocoImageRenderDataGL = new CocoImageRenderDataGL();

		// Keep WebGLRenderingContext on Image Rendering Data for deleting the texture
		data.gl = gl;

		var w2:Float = (img.textureScale * (img.textureCellWidth / 2.0) / img.pixelRatio);
		var h2:Float = (img.textureScale * (img.textureCellHeight / 2.0) / img.pixelRatio);

		// Apply image scaling
		img.resizeToOptimalTextureSize();

		// Adjust image size to design-time viewport and take into account texture scaling.
		var ox:Float = (img.binpackX / img.hImage.naturalWidth);
		var oy:Float = (img.binpackY / img.hImage.naturalHeight);
		var tx:Float = (img.textureCellWidth / img.hImage.naturalWidth);
		var ty:Float = (img.textureCellHeight / img.hImage.naturalHeight);
		var texData:Float32Array = null;

		// Create a WebGL Texture and bind it.
		data.texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, data.texture);

		// Create Texture from HTML Image
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img.hImage);
		if(gl.getError()!=0) trace("ERROR: CocoRenderContextGL::prepareImage() gl.texImage2D failed for image " + img.hImage.src);

		// Instruct WebGL how to wrap the texture.
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);

		// Generate Texture FROM iMAGE
		gl.generateMipmap(gl.TEXTURE_2D);
		if(gl.getError()!=0) trace("ERROR: CocoRenderContextGL::prepareImage() gl.generateMipmap failed for image " + img.hImage.src);

		// Unbind Texture
		gl.bindTexture(gl.TEXTURE_2D, null);

		if(img.tileMap)
		{
			// Decode Compressed TiledLayer data

			img.texSize = new Float32Array([ox, oy, img.tileWidth / img.hImage.naturalWidth, img.tileHeight / img.hImage.naturalHeight]);
			var d:Array<Float> = new Array<Float>();
			//var tileCountX:Integer = img.image.naturalWidth / img.tileWidth;
			var tileCountX:Integer = img.tileMap[0];
			var tileMapCols:Integer = img.tileMap[1];
			var tileMapRows:Integer = img.tileMap[2];
			var vCount:Integer = Math.min(tileMapCols, Integer(Math.ceil(img.textureCellWidth / img.tileWidth)));
			var hCount:Integer = Math.min(tileMapRows, Integer(Math.ceil(img.textureCellHeight / img.tileHeight)));
			var tileCount:Integer = 0;
			var paddingSize:Float = img.pixelRatio;
			for(var y:Integer = hCount; y--;)
			{
				for(var x:Integer = vCount; x--;)
				{
					var idx:Integer = img.tileMap[3 + y * tileMapCols + x];
					if(idx == -1) continue;
					var texX:Float = idx % tileCountX;
					var texY:Float = Math.floor(idx / tileCountX);
					texX += (2.0 * texX + 1.0) * paddingSize / img.tileWidth;
					texY += (2.0 * texY + 1.0) * paddingSize / img.tileHeight;
					d.push(texX); d.push(texY); d.push(0.0); d.push(0.0); d.push((x + 0) * img.tileWidth - w2); d.push((y + 0) * img.tileHeight - h2);
					d.push(texX); d.push(texY); d.push(0.0); d.push(1.0); d.push((x + 0) * img.tileWidth - w2); d.push((y + 1) * img.tileHeight - h2);
					d.push(texX); d.push(texY); d.push(1.0); d.push(1.0); d.push((x + 1) * img.tileWidth - w2); d.push((y + 1) * img.tileHeight - h2);
					d.push(texX); d.push(texY); d.push(0.0); d.push(0.0); d.push((x + 0) * img.tileWidth - w2); d.push((y + 0) * img.tileHeight - h2);
					d.push(texX); d.push(texY); d.push(1.0); d.push(1.0); d.push((x + 1) * img.tileWidth - w2); d.push((y + 1) * img.tileHeight - h2);
					d.push(texX); d.push(texY); d.push(1.0); d.push(0.0); d.push((x + 1) * img.tileWidth - w2); d.push((y + 0) * img.tileHeight - h2);
					++tileCount;
				}
			}
			texData = new Float32Array(d);
			data.drawType = gl.TRIANGLES;
			data.vertexCount = tileCount * 6;
		}
		else
		{
			img.texSize = new Float32Array([ox, oy, tx, ty]);
			texData = new Float32Array([0.0, 0.0, 0.0, 0.0, -w2, -h2, 0.0, 0.0, 0.0, 1.0, -w2, h2, 0.0, 0.0, 1.0, 0.0, w2, -h2, 0.0, 0.0, 1.0, 1.0, w2, h2]);
			data.drawType = gl.TRIANGLE_STRIP;
			data.vertexCount = 4;
		}

		// Set texture map to a WebGL Buffer
		data.buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, data.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, texData, gl.STATIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
		delete texData;

		// Return Rendering Data to CocoImage
		return data;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function prepareClip(clip:CocoClip)
	{
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	private function update(m:CocoMatrix, ul:WebGLUniformLocation)
	{
		if(!ul) return;
		if(m.__dirty) m.refresh();
		gl.uniformMatrix4fv(ul, false, m.__data);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function drawFrame(scene:CocoScene, clip:CocoClip, image:CocoImage, keyFrame:CocoKeyFrame, textureIndex:Integer)
	{
		if(!image.renderData) return;
		if(setFilter(keyFrame.filter) || __modelViewMatrix.__dirty) update(__modelViewMatrix, activeShader.uMVMat);
		activeShader.drawFrame(gl, scene, image, textureIndex, keyFrame);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
    private function setFilter(filter:Integer) :Boolean
    {
    	var nextShader:CocoShaderCommon = activeShader;
		switch(filter)
		{
		case COCO_FILTER_ENUM.FILTER_INHERIT: nextShader = shaderSimple[maskDraw ? 1 : 0]; break;
		case COCO_FILTER_ENUM.FILTER_SIMPLE: nextShader = shaderSimple[maskDraw ? 1 : 0]; break;
		case COCO_FILTER_ENUM.FILTER_SIMPLE_WITH_ALPHA: nextShader = shaderSimpleWithAlpha[maskDraw ? 1 : 0]; break;
		case COCO_FILTER_ENUM.FILTER_SATURATION_WITH_ALPHA: nextShader = shaderSaturationWithAlpha[maskDraw ? 1 : 0]; break;
		case COCO_FILTER_ENUM.FILTER_PARALLAX_HOR: nextShader = shaderParallaxHor[maskDraw ? 1 : 0]; break;
		}
		if(nextShader != activeShader)
		{
			activeShader.end(gl);
			activeShader = nextShader;
			activeShader.begin(gl);
			return true;
		}
		return false;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
	public function drawMaskBegin()
	{
		if(maskDraw) return;
		maskDraw = true;
		gl.colorMask(false, false, false, false);
		gl.stencilMask(0xFF);
		gl.stencilFunc(gl.EQUAL, 1, 0xFF);
		gl.clear(gl.STENCIL_BUFFER_BIT);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function drawMaskEnd(invert:Boolean)
	{
		if(!maskDraw) return;
		maskDraw = false;
		gl.colorMask(true, true, true, true);
		gl.stencilMask(0x00);
		gl.stencilFunc(gl.EQUAL, invert ? 0 : 1, 0xFF);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function drawBoundingBox(clip:CocoClip)
	{
		if(!clip.__hasBoundingBox) return;
		activeShader.end(gl);
		shaderBoundingBox.begin(gl);
		shaderBoundingBox.draw(gl, new Float32Array([clip.__vABS_TOP_LEFT.X, clip.__vABS_TOP_LEFT.Y, clip.__vABS_TOP_RIGHT.X, clip.__vABS_TOP_RIGHT.Y, clip.__vABS_BOTTOM_RIGHT.X, clip.__vABS_BOTTOM_RIGHT.Y, clip.__vABS_BOTTOM_LEFT.X, clip.__vABS_BOTTOM_LEFT.Y]));
		shaderBoundingBox.end(gl);
		activeShader.begin(gl);
	}
}
