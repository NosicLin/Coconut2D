"#export native";
"#export web";

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2014 www.coconut2D.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	   ______                 ____                 __          ______            __            __  ________
//	  / ____/___  _________  / __ \___  ____  ____/ /__  _____/ ____/___  ____  / /____  _  __/ /_/ ____/ /
//	 / /   / __ \/ ___/ __ \/ /_/ / _ \/ __ \/ __  / _ \/ ___/ /   / __ \/ __ \/ __/ _ \| |/_/ __/ / __/ /
//	/ /___/ /_/ / /__/ /_/ / _, _/  __/ / / / /_/ /  __/ /  / /___/ /_/ / / / / /_/  __/>  </ /_/ /_/ / /___
//	\____/\____/\___/\____/_/ |_|\___/_/ /_/\__,_/\___/_/   \____/\____/_/ /_/\__/\___/_/|_|\__/\____/_____/
//
// ==================================================================================================================================

class CocoRenderContextGL implements ICocoRenderContext
{
	// WebGL Context
	private reference var gl:WebGLRenderingContext;

	// Matrix
	private var __modelViewMatrix:CocoMatrix;
	private var __projectionMatrix:CocoMatrix;
	private var __viewportVector:CocoVector;

	private var maskDraw:Boolean;

	// Shaders
	private reference var activeShader:CocoShaderCommon;
	private var shaderSimple:Array<CocoShaderSimple>;
	private var shaderSimpleWithAlpha:Array<CocoShaderSimpleWithAlpha>;
	private var shaderSaturationWithAlpha:Array<CocoShaderSaturationWithAlpha>;
	private var shaderParallaxHor:Array<CocoShaderParallaxHor>;
	private var shaderBoundingBox:CocoShaderBoundingBox;

	///////////////////////////////////////////////////////////////////////////////////////////////
 	public function Constructor(ctx:WebGLRenderingContext)
 	{
 		gl = ctx;

		__modelViewMatrix = new CocoMatrix();
		__projectionMatrix = new CocoMatrix();
		__viewportVector = new CocoVector();

		maskDraw = false;

		activeShader = null;

		shaderSimple = new Array<CocoShaderSimple>();
		shaderSimple.push(new CocoShaderSimple());
		shaderSimple.push(new CocoShaderSimple(true));

		shaderSimpleWithAlpha = new Array<CocoShaderSimpleWithAlpha>();
		shaderSimpleWithAlpha.push(new CocoShaderSimpleWithAlpha());
		shaderSimpleWithAlpha.push(new CocoShaderSimpleWithAlpha(true));

		shaderSaturationWithAlpha = new Array<CocoShaderSaturationWithAlpha>();
		shaderSaturationWithAlpha.push(new CocoShaderSaturationWithAlpha());
		shaderSaturationWithAlpha.push(new CocoShaderSaturationWithAlpha(true));

		shaderParallaxHor = new Array<CocoShaderParallaxHor>();
		shaderParallaxHor.push(new CocoShaderParallaxHor());
		shaderParallaxHor.push(new CocoShaderParallaxHor(true));

		shaderBoundingBox = new CocoShaderBoundingBox();
 	}

	///////////////////////////////////////////////////////////////////////////////////////////////
 	public function Destructor()
 	{
		delete __modelViewMatrix;
		delete __projectionMatrix;
		delete __viewportVector;
		delete shaderSimple;
		delete shaderSimpleWithAlpha;
		delete shaderSaturationWithAlpha;
		delete shaderParallaxHor;
		delete shaderBoundingBox;
 	}

 	///////////////////////////////////////////////////////////////////////////////////////////////
	public function getGLContext():WebGLRenderingContext
	{
		return gl;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
 	public function flush()
 	{
 	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function getModelViewMatrix():CocoMatrix
	{
		return __modelViewMatrix;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function getProjectionMatrix():CocoMatrix
	{
		return __projectionMatrix;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function getWidth():Float
	{
		return gl.canvas.width;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function getHeight():Float
	{
		return gl.canvas.height;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function cls()
	{
		__modelViewMatrix.identity();
		gl.clearColor(0,0,0,1);
 		gl.clear(gl.COLOR_BUFFER_BIT);
 		gl.stencilMask(0x00);
    	//gl.useProgram(__glProgram);
    	//gl.enableVertexAttribArray(__glProgram.GLSLiVecCoords);
		//gl.enableVertexAttribArray(__glProgram.GLSLiTexCoords);
    	//__projectionMatrix.update(gl, __glProgram_Simple.GLSLuProjMat);
    	//__modelViewMatrix.update(gl, __glProgram.GLSLuMVMat);
    	//engine.__debug_trace(this, null, "@CYCLE");
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function ready():Boolean
	{
		return true;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function prepare(scene:CocoScene)
	{
		gl.enable(gl.STENCIL_TEST);
		gl.stencilFunc(gl.EQUAL, 0, 0xFF);
		gl.stencilMask(0x00);
		gl.stencilOp(gl.REPLACE, gl.KEEP, gl.KEEP);
		gl.disable(gl.DEPTH_TEST);
		gl.enable(gl.BLEND);
		gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
		gl.disable(gl.CULL_FACE);

		// Prepare orthographic projection matrix
		if(window.deviceRotation)
		{
			var c:Float = Math.cos(window.deviceRotation);
			var s:Float = Math.sin(window.deviceRotation);
			var orthoWidth:Float = Math.abs(c * Float(gl.canvas.width) + s * Float(gl.canvas.height));
			var orthoHeight:Float = Math.abs(-s * Float(gl.canvas.width) + c * Float(gl.canvas.height));
			__projectionMatrix.ortho(-orthoWidth / 2.0, orthoWidth / 2.0, orthoHeight / 2.0,  -orthoHeight / 2.0, -1.0, 1.0);
			__projectionMatrix.rotateZ(-window.deviceRotation);
		}
		else
		{
			__projectionMatrix.ortho( -(Float(gl.canvas.width) / 2.0), Float(gl.canvas.width) / 2.0, Float(gl.canvas.height) / 2.0,  -(Float(gl.canvas.height) / 2.0), -1.0, 1.0);
		}
		__projectionMatrix.scale(scene.__view_scale, scene.__view_scale);

		__modelViewMatrix.identity();
		__viewportVector.reset(-(Float(gl.canvas.width) / 2.0) / scene.__view_scale, Float(gl.canvas.width) / 2.0 / scene.__view_scale, Float(gl.canvas.height) / 2.0 / scene.__view_scale, -(Float(gl.canvas.height) / 2.0 / scene.__view_scale));

		shaderBoundingBox.initialize(gl, __projectionMatrix);
		shaderSimple[0].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderSimple[1].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderSimpleWithAlpha[0].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderSimpleWithAlpha[1].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderSaturationWithAlpha[0].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderSaturationWithAlpha[1].initialize(gl, __projectionMatrix, __modelViewMatrix);
		shaderParallaxHor[0].initialize(gl, __projectionMatrix, __modelViewMatrix, __viewportVector);
		shaderParallaxHor[1].initialize(gl, __projectionMatrix, __modelViewMatrix, __viewportVector);

		activeShader = shaderSimple[0];
		activeShader.begin(gl);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function prepareImage(img:CocoImage):ICocoImageRenderData
	{
		var data:CocoImageRenderDataGL = new CocoImageRenderDataGL();

		// Create a texture and bind it.
		data.texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, data.texture);

		var sImg:Image = img.image;
		if(img.scaleX > 0.0 && img.scaleY > 0.0)
		{
			var canvas:HTMLCanvasElement = HTMLCanvasElement(document.createElement("canvas"));
			canvas.width = Math.floor(img.image.naturalWidth * img.scaleX / img.pixelRatio);
			canvas.height = Math.floor(img.image.naturalHeight * img.scaleY / img.pixelRatio);
			trace("Scaling image to " + String(canvas.width) + "x" + String(canvas.height) + " (x" + String(img.scaleX / img.pixelRatio) + ", x" + String(img.scaleY / img.pixelRatio) + ", @" + String(img.pixelRatio) + "): " + img.symbolName);
			var c2d:CanvasRenderingContext2D = CanvasRenderingContext2D(canvas.getContext("2d"));
			c2d.drawImage(img.image, 0.0, 0.0, canvas.width, canvas.height);
			sImg = new Image();
			sImg.load(canvas.toDataURL());
		}

		// Load image data to texture.
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, sImg);

		// Unload the HTML Image to save memory.
		// Works only on native, HTML5 browsers need the image.

		// Instruct WebGL how to wrap the texture.
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

		// Instruct WebGL how to filter the texture when rendering.
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST_MIPMAP_LINEAR);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_LINEAR);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST_MIPMAP_NEAREST);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR_MIPMAP_NEAREST);
		//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);

		// Generate mipmaps.
		gl.generateMipmap(gl.TEXTURE_2D);

		// Done
		gl.bindTexture(gl.TEXTURE_2D, null);

		var w2:Float = img.textureCellWidth / 2.0;
		var h2:Float = img.textureCellHeight / 2.0;
		var texData:Float32Array = null;
		if(img.tileMap)
		{
			img.texSize = new Float32Array([img.tileWidth / img.image.naturalWidth, img.tileHeight / img.image.naturalHeight]);
			var d:Array<Float> = new Array<Float>();
			//var tileCountX:Integer = img.image.naturalWidth / img.tileWidth;
			var tileCountX:Integer = img.tileMap[0];
			var tileMapCols:Integer = img.tileMap[1];
			var tileMapRows:Integer = img.tileMap[2];
			var vCount:Integer = Math.min(tileMapCols, Integer(Math.ceil(img.textureCellWidth / img.tileWidth)));
			var hCount:Integer = Math.min(tileMapRows, Integer(Math.ceil(img.textureCellHeight / img.tileHeight)));
			var tileCount:Integer = 0;
			var paddingSize:Float = img.pixelRatio;
			for(var y:Integer = hCount; y--;)
			{
				for(var x:Integer = vCount; x--;)
				{
					var idx:Integer = img.tileMap[3 + y * tileMapCols + x];
					if(idx == -1) continue;
					var texX:Float = idx % tileCountX;
					var texY:Float = Math.floor(idx / tileCountX);
					texX += (2.0 * texX + 1.0) * paddingSize / img.tileWidth;
					texY += (2.0 * texY + 1.0) * paddingSize / img.tileHeight;
					d.push(texX); d.push(texY); d.push(0.0); d.push(0.0); d.push((x + 0) * img.tileWidth - w2); d.push((y + 0) * img.tileHeight - h2);
					d.push(texX); d.push(texY); d.push(0.0); d.push(1.0); d.push((x + 0) * img.tileWidth - w2); d.push((y + 1) * img.tileHeight - h2);
					d.push(texX); d.push(texY); d.push(1.0); d.push(1.0); d.push((x + 1) * img.tileWidth - w2); d.push((y + 1) * img.tileHeight - h2);
					d.push(texX); d.push(texY); d.push(0.0); d.push(0.0); d.push((x + 0) * img.tileWidth - w2); d.push((y + 0) * img.tileHeight - h2);
					d.push(texX); d.push(texY); d.push(1.0); d.push(1.0); d.push((x + 1) * img.tileWidth - w2); d.push((y + 1) * img.tileHeight - h2);
					d.push(texX); d.push(texY); d.push(1.0); d.push(0.0); d.push((x + 1) * img.tileWidth - w2); d.push((y + 0) * img.tileHeight - h2);
					++tileCount;
				}
			}
			texData = new Float32Array(d);
			data.drawType = gl.TRIANGLES;
			data.vertexCount = tileCount * 6;
		}
		else
		{
			img.texSize = new Float32Array([img.textureCellWidth / img.image.naturalWidth, img.textureCellHeight / img.image.naturalHeight]);
			texData = new Float32Array([0.0, 0.0, 0.0, 0.0, -w2, -h2, 0.0, 0.0, 0.0, 1.0, -w2, h2, 0.0, 0.0, 1.0, 0.0, w2, -h2, 0.0, 0.0, 1.0, 1.0, w2, h2]);
			data.drawType = gl.TRIANGLE_STRIP;
			data.vertexCount = 4;
		}
		data.buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, data.buffer);
		gl.bufferData(gl.ARRAY_BUFFER, texData, gl.STATIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
		delete texData;

		return data;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	private function update(m:CocoMatrix, ul:WebGLUniformLocation)
	{
		if(!ul) return;
		if(m.__dirty) m.refresh();
		gl.uniformMatrix4fv(ul, false, m.__data);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function drawFrame(scene:CocoScene, image:CocoImage, frame:Integer, KF:CocoKeyFrame)
	{
		if(!image.renderData) return;
		if(setFilter(KF.filter) || __modelViewMatrix.__dirty) update(__modelViewMatrix, activeShader.uMVMat);
		activeShader.drawFrame(gl, scene, image, frame, KF);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
    private function setFilter(filter:Integer) :Boolean
    {
    	var nextShader:CocoShaderCommon = activeShader;
		switch(filter)
		{
		case COCO_FILTER_ENUM.FILTER_INHERIT: nextShader = shaderSimple[maskDraw ? 1 : 0]; break;
		case COCO_FILTER_ENUM.FILTER_SIMPLE: nextShader = shaderSimple[maskDraw ? 1 : 0]; break;
		case COCO_FILTER_ENUM.FILTER_SIMPLE_WITH_ALPHA: nextShader = shaderSimpleWithAlpha[maskDraw ? 1 : 0]; break;
		case COCO_FILTER_ENUM.FILTER_SATURATION_WITH_ALPHA: nextShader = shaderSaturationWithAlpha[maskDraw ? 1 : 0]; break;
		case COCO_FILTER_ENUM.FILTER_PARALLAX_HOR: nextShader = shaderParallaxHor[maskDraw ? 1 : 0]; break;
		}
		if(nextShader != activeShader)
		{
			activeShader.end(gl);
			activeShader = nextShader;
			activeShader.begin(gl);
			return true;
		}
		return false;
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
	public function drawMaskBegin()
	{
		if(maskDraw) return;
		maskDraw = true;
		gl.colorMask(false, false, false, false);
		gl.stencilMask(0xFF);
		gl.stencilFunc(gl.EQUAL, 1, 0xFF);
		gl.clear(gl.STENCIL_BUFFER_BIT);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function drawMaskEnd(invert:Boolean)
	{
		if(!maskDraw) return;
		maskDraw = false;
		gl.colorMask(true, true, true, true);
		gl.stencilMask(0x00);
		gl.stencilFunc(gl.EQUAL, invert ? 0 : 1, 0xFF);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function drawBoundingBox(clip:CocoClip)
	{
		if(!clip.__hasBoundingBox) return;

		activeShader.end(gl);
		shaderBoundingBox.begin(gl);
		shaderBoundingBox.draw(gl, new Float32Array([clip.__vABS_TOP_LEFT.X, clip.__vABS_TOP_LEFT.Y, clip.__vABS_TOP_RIGHT.X, clip.__vABS_TOP_RIGHT.Y, clip.__vABS_BOTTOM_RIGHT.X, clip.__vABS_BOTTOM_RIGHT.Y, clip.__vABS_BOTTOM_LEFT.X, clip.__vABS_BOTTOM_LEFT.Y]));
		shaderBoundingBox.end(gl);
		activeShader.begin(gl);
	}
}
