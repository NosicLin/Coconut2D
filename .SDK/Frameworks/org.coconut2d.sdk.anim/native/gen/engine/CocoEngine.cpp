/* Generated by Coconut2D C++ Compiler from file CocoEngine.jspp */

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "CocoEngine.hpp"
#include "ITickable.hpp"
#include "ICocoRenderContext.hpp"
#include "CocoClip.hpp"
#include "DeviceMessage.hpp"
#include "HTMLWindow.hpp"
#include "CocoRenderContext.hpp"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
CocoEngine::CocoEngine()
{
	__clock = 0;
	__currentState = nullptr;
	__tickables = new Array<ITickable*> ();
	__ctx = CocoRenderContext::createContext();
	__attachDevices();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
CocoEngine::~CocoEngine()
{
	__dettachDevices();
	if(__ctx)
	{
		__ctx = (delete __ctx, nullptr);
	}
	if(__clicked)
	{
		__clicked = (delete __clicked, nullptr);
	}
	if(__tickables)
	{
		__tickables = (delete __tickables, nullptr);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::setNextState(State* s)
{
	__nextState = s;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::run(float time)
{
	if(!__currentState && !__nextState)
	{
		return;
	}
	if(__nextState != nullptr)
	{
		if(__currentState)
		{
			__currentState->exit();
		}
		__currentState = __nextState;
		__nextState = nullptr;
		trace((String("\n@@STATE ") + __currentState->__name).c_str());
		__clicked->clear();
		if(__currentState)
		{
			__currentState->enter();
		}
	}
	if(__currentState)
	{
		__currentState->tick(__clock);
	}
	__tick(__clock);
	if(__nextState == nullptr && __currentState != nullptr)
	{
		__ctx->cls();
		__currentState->paint(__ctx, __clock);
		__ctx->flush();
	}
	__clicked->clear();
	__clearDeviceMessageQueue();
	__clock += TICK_TIME;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__attachDevices()
{
	__deviceMessageQueue = new Array<DEVICE_MESSAGE*> ();
	__clicked = new Array<CocoClip*> ();
	__track_touch = false;
	__has_touch_device_message = false;
	if(global->__native)
	{
		window->addEventListener(String("touchstart"), &CocoEngine::__translateDeviceMessage);
		window->addEventListener(String("touchmove"), &CocoEngine::__translateDeviceMessage);
		window->addEventListener(String("touchend"), &CocoEngine::__translateDeviceMessage);
	}
	else
	{
		window->addEventListener(String("mousedown"), &CocoEngine::__translateDeviceMessage);
		window->addEventListener(String("mousemove"), &CocoEngine::__translateDeviceMessage);
		window->addEventListener(String("mouseup"), &CocoEngine::__translateDeviceMessage);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__dettachDevices()
{
	if(global->__native)
	{
		window->removeEventListener(String("touchstart"), &CocoEngine::__translateDeviceMessage);
		window->removeEventListener(String("touchmove"), &CocoEngine::__translateDeviceMessage);
		window->removeEventListener(String("touchend"), &CocoEngine::__translateDeviceMessage);
	}
	else
	{
		window->removeEventListener(String("mousedown"), &CocoEngine::__translateDeviceMessage);
		window->removeEventListener(String("mousemove"), &CocoEngine::__translateDeviceMessage);
		window->removeEventListener(String("mouseup"), &CocoEngine::__translateDeviceMessage);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__translateDeviceMessage(HTMLEvent* e)
{
	DEVICE_MESSAGE* MSG;
	if(e->type == String("mousedown"))
	{
		switch(0)
		{
			case 0:
			{
				if(!__track_touch)
				{
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_START;
					MSG->x0 = e->clientX;
					MSG->y0 = e->clientY;
					__track_touch = true;
					__has_touch_device_message = true;
				}
				break;
			}
		}
	}
	else if(e->type == String("mousemove"))
	{
		switch(0)
		{
			case 0:
			{
				if(__track_touch)
				{
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_MOVE;
					MSG->x0 = e->clientX;
					MSG->y0 = e->clientY;
					__has_touch_device_message = true;
				}
				break;
			}
		}
	}
	else if(e->type == String("mouseup"))
	{
		switch(0)
		{
			case 0:
			{
				if(__track_touch)
				{
					__removeTouchMessages();
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_END;
					MSG->x0 = e->clientX;
					MSG->y0 = e->clientY;
					__track_touch = false;
					__has_touch_device_message = true;
				}
				break;
			}
		}
	}
	else if(e->type == String("touchstart"))
	{
		switch(0)
		{
			case 0:
			{
				if(!__track_touch)
				{
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_START;
					MSG->x0 = (*e->touches)[0]->clientX;
					MSG->y0 = (*e->touches)[0]->clientY;
					__track_touch = true;
					__has_touch_device_message = true;
				}
				break;
			}
		}
	}
	else if(e->type == String("touchmove"))
	{
		switch(0)
		{
			case 0:
			{
				if(__track_touch)
				{
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_MOVE;
					MSG->x0 = (*e->touches)[0]->clientX;
					MSG->y0 = (*e->touches)[0]->clientY;
					__has_touch_device_message = true;
				}
				break;
			}
		}
	}
	else if(e->type == String("touchend"))
	{
		switch(0)
		{
			case 0:
			{
				if(__track_touch)
				{
					__removeTouchMessages();
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_END;
					MSG->x0 = (*e->touches)[0]->clientX;
					MSG->y0 = (*e->touches)[0]->clientY;
					__track_touch = false;
					__has_touch_device_message = true;
				}
				break;
			}
		}
	}
	if(MSG)
	{
		__deviceMessageQueue->push(MSG);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
bool CocoEngine::__hasTouchDeviceMessage()
{
	return (__has_touch_device_message && __deviceMessageQueue->size() > 0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__removeTouchMessages()
{
	if(!__has_touch_device_message)
	{
		return;
	}
	for(int i = __deviceMessageQueue->size(); i--;)
		if(((*__deviceMessageQueue)[i]->type & DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_MASK) != 0)
		{
			__deviceMessageQueue->splice(i, 1);
		}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
DEVICE_MESSAGE* CocoEngine::__peekDeviceMessage(DEVICE_MESSAGE_ENUM mask)
{
	int L = __deviceMessageQueue->size();
	for(int i = 0; i < L; i++)
		if(((*__deviceMessageQueue)[i]->type & mask) != 0)
		{
			return (*__deviceMessageQueue)[i];
		}
	return nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__clearDeviceMessageQueue()
{
	__deviceMessageQueue->clear();
	__has_touch_device_message = false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__pushClicked(CocoClip* clip)
{
	__clicked->push(clip);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
int CocoEngine::isClicked(Array<CocoClip*>* check)
{
	for(int i = __clicked->size(); i--;)
		for(int r = check->size(); r--;)
			if((*check)[r] == (*__clicked)[i])
			{
				return r;
			}
	return  -1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::addTickListener(ITickable* tickable)
{
	__tickables->push(tickable);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::removeTickListener(ITickable* tickable)
{
	int index = getTickableIndex(tickable);
	if(index != -1)
	{
		__tickables->splice(index, 1);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
int CocoEngine::getTickableIndex(ITickable* tickable)
{
	if(tickable)
		for(int i = __tickables->size(); i--;)
			if((*__tickables)[i] == tickable)
			{
				return i;
			}
	return  -1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__tick(float time)
{
	for(int i = __tickables->size(); i--;)
	{
		(*__tickables)[i]->tick(time);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__debug_trace(CocoScene* scene, CocoClip* clip, String message)
{
}
