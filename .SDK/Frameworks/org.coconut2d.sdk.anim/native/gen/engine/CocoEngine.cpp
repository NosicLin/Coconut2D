/* Generated by Coconut2D C++ Compiler from file CocoEngine.jspp */

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "CocoEngine.hpp"
#include "ITickable.hpp"
#include "ICocoRenderContext.hpp"
#include "CocoClip.hpp"
#include "DeviceMessage.hpp"
#include "HTMLWindow.hpp"
#include "CocoRenderContext.hpp"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
CocoEngine::CocoEngine()
{
	__ctx = CocoRenderContext::createContext();
	__currentState = nullptr;
	__clock = 0;
	debugbreak = false;
	__attachDevice();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
CocoEngine::~CocoEngine()
{
	if(__ctx)
	{
		__ctx = (delete __ctx, nullptr);
	}
	if(__clicked)
	{
		__clicked = (delete __clicked, nullptr);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::addTickListener(ITickable* tickable)
{
	__tickables->push(tickable);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
int CocoEngine::getTickableIndex(ITickable* tickable)
{
	if(tickable)
	{
		for(int i = __tickables->size() - 1; i >= 0; i--)
		{
			if((*__tickables)[i] == tickable)
			{
				return i;
			}
		}
	}
	return  -1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::removeTickListener(ITickable* tickable)
{
	int index = getTickableIndex(tickable);
	if(index != -1)
	{
		__tickables->splice(index, 1);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::setNextState(State* s)
{
	__nextState = s;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::run(float time)
{
	if(!__currentState && !__nextState)
	{
		return;
	}
	if(__nextState != nullptr)
	{
		if(__currentState)
		{
			__currentState->exit();
		}
		__currentState = __nextState;
		__nextState = nullptr;
		trace((String("\n@@STATE ") + __currentState->__name).c_str());
		__clicked->clear();
		if(__currentState)
		{
			__currentState->enter();
		}
	}
	if(__currentState)
	{
		int i = 0;
		for(i = 0; i < __clicked->size(); i++)
		{
			CocoClip* clip = (*__clicked)[i];
		}
		__currentState->tick(__clock);
	}
	__clicked->clear();
	if(__nextState == nullptr && __currentState != nullptr)
	{
		__ctx->cls();
		__currentState->paint(__ctx, __clock);
		__ctx->flush();
	}
	__deviceMessageQueue->clear();
	__clock += TICK_TIME;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__debug_trace(CocoScene* scene, CocoClip* clip, String message)
{
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__attachDevice()
{
	__track_mouse = false;
	__device_message_index = 0;
	__deviceMessageQueue = new Array<DEVICE_MESSAGE*> ();
	__clicked = new Array<CocoClip*> ();
	if(global->__native)
	{
		window->addEventListener(String("touchstart"), &CocoEngine::__translateDeviceMessage);
		window->addEventListener(String("touchmove"), &CocoEngine::__translateDeviceMessage);
		window->addEventListener(String("touchend"), &CocoEngine::__translateDeviceMessage);
	}
	else
	{
		window->addEventListener(String("mousedown"), &CocoEngine::__translateDeviceMessage);
		window->addEventListener(String("mousemove"), &CocoEngine::__translateDeviceMessage);
		window->addEventListener(String("mouseup"), &CocoEngine::__translateDeviceMessage);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__translateDeviceMessage(HTMLEvent* e)
{
	DEVICE_MESSAGE* MSG = nullptr;
	if(e->type == String("mousedown"))
	{
		switch(0)
		{
			case 0:
			{
				if(!__track_mouse)
				{
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_START;
					MSG->x0 = e->clientX;
					MSG->y0 = e->clientY;
					__track_mouse = true;
				}
				break;
			}
		}
	}
	else if(e->type == String("mousemove"))
	{
		switch(0)
		{
			case 0:
			{
				if(__track_mouse)
				{
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_MOVE;
					MSG->x0 = e->clientX;
					MSG->y0 = e->clientY;
				}
				break;
			}
		}
	}
	else if(e->type == String("mouseup"))
	{
		switch(0)
		{
			case 0:
			{
				if(__track_mouse)
				{
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_END;
					MSG->x0 = e->clientX;
					MSG->y0 = e->clientY;
					__track_mouse = false;
				}
				break;
			}
		}
	}
	else if(e->type == String("touchstart"))
	{
		switch(0)
		{
			case 0:
			{
				if(!__track_mouse)
				{
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_START;
					MSG->x0 = (*e->touches)[0]->clientX;
					MSG->y0 = (*e->touches)[0]->clientY;
					__track_mouse = true;
				}
				break;
			}
		}
	}
	else if(e->type == String("touchmove"))
	{
		switch(0)
		{
			case 0:
			{
				if(__track_mouse)
				{
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_MOVE;
					MSG->x0 = (*e->touches)[0]->clientX;
					MSG->y0 = (*e->touches)[0]->clientY;
				}
				break;
			}
		}
	}
	else if(e->type == String("touchend"))
	{
		switch(0)
		{
			case 0:
			{
				if(__track_mouse)
				{
					MSG = new DEVICE_MESSAGE();
					MSG->type = DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_END;
					MSG->x0 = (*e->touches)[0]->clientX;
					MSG->y0 = (*e->touches)[0]->clientY;
					__track_mouse = false;
				}
				break;
			}
		}
	}
	if(MSG)
	{
		__deviceMessageQueue->push(MSG);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
DEVICE_MESSAGE* CocoEngine::__peekDeviceMessage(DEVICE_MESSAGE_ENUM mask, bool first)
{
	if(first)
	{
		__device_message_index = 0;
	}
	else
	{
		__device_message_index++;
	}
	int L = __deviceMessageQueue->size();
	if(__device_message_index < L)
	{
		DEVICE_MESSAGE* msg;
		for(int i = __device_message_index; i < L; i++)
		{
			msg = (*__deviceMessageQueue)[i];
			if((msg->type & mask) != 0)
			{
				__device_message_index = i;
				msg->peeked = true;
				return msg;
			}
		}
	}
	return nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__clearDeviceMessageQueue()
{
	DEVICE_MESSAGE* msg;
	int L = __deviceMessageQueue->size();
	for(int i = L; i < L; i++)
	{
		msg = (*__deviceMessageQueue)[i];
		if(msg->peeked)
		{
			__deviceMessageQueue->splice(i, 1);
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoEngine::__pushTouched(CocoClip* clip)
{
	trace((String("click: ") + clip->__instanceName).c_str());
	__clicked->push(clip);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
int CocoEngine::isClicked(Array<CocoClip*>* check)
{
	for(int i = __clicked->size() - 1; i >= 0; i--)
		for(int r = check->size() - 1; r >= 0; r--)
			if((*check)[r] == (*__clicked)[i])
			{
				return r;
			}
	return  -1;
}
