/* Generated by Coconut2D C++ Compiler from file CocoClip.jspp */

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "CocoClip.hpp"
#include "CocoScene.hpp"
#include "Constants.hpp"
#include "CocoTimeline.hpp"
#include "ICocoRenderContext.hpp"
#include "CocoMatrix.hpp"
#include "DeviceMessage.hpp"
#include "CocoImage.hpp"
#include "CocoGraphics.hpp"
#include "CocoAudio.hpp"
#include "CocoEngine.hpp"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////
CocoClip::CocoClip(CocoImage* image)
{
	this->OnClick = new CocoClipOnClickEvent;
	this->OnTouchStart = new CocoClipOnTouchStartEvent;
	this->OnTouchMove = new CocoClipOnTouchMoveEvent;
	this->OnTouchEnd = new CocoClipOnTouchEndEvent;
	__symbolLoop = COCO_CLIP_SYMBOL_LOOP_ENUM::CLIP_SYMBOL_LOOP_CONTINUOUS;
	__timeline = new CocoTimeline();
	__children = new Array<CocoClip*> ();
	__parent = nullptr;
	__currentTime = 0.0;
	__currentFrame = nullptr;
	__hasBoundingBox = false;
	__vABS_TOP_LEFT = new CocoVector();
	__vABS_TOP_RIGHT = new CocoVector();
	__vABS_BOTTOM_LEFT = new CocoVector();
	__vABS_BOTTOM_RIGHT = new CocoVector();
	__vREL_TOP_LEFT = new CocoVector();
	__vREL_TOP_RIGHT = new CocoVector();
	__vREL_BOTTOM_LEFT = new CocoVector();
	__vREL_BOTTOM_RIGHT = new CocoVector();
	__vBBoxVrtx = new CocoVector();
	__mBBox = new CocoMatrix();
	__touch_start_point = new CocoPoint();
	__childWithMaxTimelineDuration = nullptr;
	__currentSequence = nullptr;
	__currentAudio = nullptr;
	__clipPath = String("");
	__image = image;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
CocoClip::~CocoClip()
{
	if(this->OnClick)
	{
		this->OnClick = (delete this->OnClick, nullptr);
	}
	if(this->OnTouchStart)
	{
		this->OnTouchStart = (delete this->OnTouchStart, nullptr);
	}
	if(this->OnTouchMove)
	{
		this->OnTouchMove = (delete this->OnTouchMove, nullptr);
	}
	if(this->OnTouchEnd)
	{
		this->OnTouchEnd = (delete this->OnTouchEnd, nullptr);
	}
	if(__children)
	{
		__children = (delete __children, nullptr);
	}
	if(__timeline)
	{
		__timeline = (delete __timeline, nullptr);
	}
	if(__vABS_TOP_LEFT)
	{
		__vABS_TOP_LEFT = (delete __vABS_TOP_LEFT, nullptr);
	}
	if(__vABS_TOP_RIGHT)
	{
		__vABS_TOP_RIGHT = (delete __vABS_TOP_RIGHT, nullptr);
	}
	if(__vABS_BOTTOM_LEFT)
	{
		__vABS_BOTTOM_LEFT = (delete __vABS_BOTTOM_LEFT, nullptr);
	}
	if(__vABS_BOTTOM_RIGHT)
	{
		__vABS_BOTTOM_RIGHT = (delete __vABS_BOTTOM_RIGHT, nullptr);
	}
	if(__vREL_TOP_LEFT)
	{
		__vREL_TOP_LEFT = (delete __vREL_TOP_LEFT, nullptr);
	}
	if(__vREL_TOP_RIGHT)
	{
		__vREL_TOP_RIGHT = (delete __vREL_TOP_RIGHT, nullptr);
	}
	if(__vREL_BOTTOM_LEFT)
	{
		__vREL_BOTTOM_LEFT = (delete __vREL_BOTTOM_LEFT, nullptr);
	}
	if(__vREL_BOTTOM_RIGHT)
	{
		__vREL_BOTTOM_RIGHT = (delete __vREL_BOTTOM_RIGHT, nullptr);
	}
	if(__vBBoxVrtx)
	{
		__vBBoxVrtx = (delete __vBBoxVrtx, nullptr);
	}
	if(__mBBox)
	{
		__mBBox = (delete __mBBox, nullptr);
	}
	if(__touch_start_point)
	{
		__touch_start_point = (delete __touch_start_point, nullptr);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::prepare(CocoScene* scene)
{
	__timeline->prepare(scene, this);
	for(int i = __children->size() - 1; i >= 0; i--)
	{
		(*__children)[i]->prepare(scene);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::setText(String text)
{
	setText(text, textFontName, textFontSize, textHAlign, textVAlign, textMultiline, textTrimming, textColor, textWidth, textHeight);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::setText(String text, String fontName, int fontSizePixels, COCO_TEXT_ALIGN_ENUM hAlign, COCO_TEXT_ALIGN_ENUM vAlign, bool multiline, COCO_TEXT_TRIMMING_ENUM trimming, String CSSColor, int textRectWidth, int textRectHeight)
{
	this->text = text;
	this->textFontName = fontName;
	this->textFontSize = fontSizePixels;
	this->textHAlign = hAlign;
	this->textVAlign = vAlign;
	this->textMultiline = multiline;
	this->textTrimming = trimming;
	this->textColor = CSSColor;
	this->textWidth = textRectWidth;
	this->textHeight = textRectHeight;
	if(__image)
	{
		__image = (delete __image, nullptr);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::reset()
{
	if(__currentFrame)
		if(__currentFrame)
		{
			__currentFrame = (delete __currentFrame, nullptr);
		}
	__currentFrame = nullptr;
	__currentTime = 0.0;
	__timeline->reset();
	for(int i = __children->size() - 1; i >= 0; i--)
	{
		(*__children)[i]->reset();
	}
	if(__currentAudio)
	{
		__currentAudio->reset();
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::clear()
{
	__children->clear();
}

////////////////////////////////////////////////////////////////////////////////////////////////////
CocoClip* CocoClip::addChild(CocoClip* clipInstance)
{
	if(!clipInstance)
	{
		return nullptr;
	}
	if(!clipInstance->__instanceName)
	{
		throw CocoException(String("Invalid instance name."));
	}
	__children->push(clipInstance);
	clipInstance->__parent = this;
	normalize();
	clipInstance->__clipPath = (__clipPath ? __clipPath : __instanceName) + String("/") + clipInstance->__instanceName;
	return clipInstance;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
CocoClip* CocoClip::removeChild(CocoClip* clipInstance)
{
	if(!clipInstance)
	{
		return nullptr;
	}
	int index = getChildIndex(clipInstance);
	clipInstance->__parent = nullptr;
	if(index == -1)
	{
		return nullptr;
	}
	__children->splice(index, 1);
	normalize();
	return clipInstance;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::normalize()
{
	__childWithMaxTimelineDuration = nullptr;
	for(int i = __children->size() - 1; i >= 0; i--)
	{
		if(!__childWithMaxTimelineDuration)
		{
			__childWithMaxTimelineDuration = (*__children)[i];
			continue;
		}
		if((*__children)[i]->__timeline->__durationInTime > __childWithMaxTimelineDuration->__timeline->__durationInTime)
		{
			__childWithMaxTimelineDuration = (*__children)[i];
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
CocoClip* CocoClip::getChildByName(String instanceName)
{
	for(int i = __children->size() - 1; i >= 0; i--)
	{
		if((*__children)[i]->__instanceName == instanceName)
		{
			return (*__children)[i];
		}
	}
	return nullptr;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
int CocoClip::getChildIndex(CocoClip* child)
{
	if(child)
	{
		for(int i = __children->size() - 1; i >= 0; i--)
		{
			if((*__children)[i] == child)
			{
				return i;
			}
		}
	}
	return  -1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
bool CocoClip::gotoFrameByName(String LabelName, bool pause)
{
	CocoTimeLabel* Label = __timeline->findLabelByName(LabelName);
	if(!Label)
	{
		return false;
	}
	return gotoFrameByIndex(Label->frameIndex, pause);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
bool CocoClip::gotoFrameByIndex(int FrameIndex, bool pause)
{
	CocoClip* clip;
	for(int i = __children->size() - 1; i >= 0; i--)
	{
		clip = (*__children)[i];
		if(FrameIndex == COCO_STOP_ON_CURRENT_FRAME)
		{
			FrameIndex = clip->__currentFrame ? clip->__currentFrame->frameIndex : 0;
		}
		clip->__timeline->__paused = pause;
		clip->__timeline->__currentFrameIndex = -1;
		clip->__currentTime = ((float)FrameIndex) * clip->__timeline->__singleFrameDurationTime;
	}
	return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::__advanceTime(float parentClipsDuration)
{
	if(__timeline->__paused)
	{
		return;
	}
	__currentTime += engine->TICK_TIME;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::paint(ICocoRenderContext* ctx, CocoScene* scene, CocoClip* parentClip, bool calcBoundingBox, int level)
{
	__scene = scene;
	CocoMatrix* mv = ctx->getModelViewMatrix();
	float __pixelRatioScale = 0;
	float parentClipsDuration = parentClip ? parentClip->__childWithMaxTimelineDuration->__timeline->__durationInTime : __timeline->__singleFrameDurationTime;
	if(parentClip)
	{
		__loops = floor((float)(__currentTime) / (float)(parentClipsDuration));
		__loopTime = __currentTime - (((float)__loops) * parentClipsDuration);
		float frameIndex = (float)(__loopTime) / (float)(__timeline->__singleFrameDurationTime);
		if(__currentFrame)
			if(__currentFrame)
			{
				__currentFrame = (delete __currentFrame, nullptr);
			}
		__currentFrame = __timeline->interpolate(frameIndex);
		if(!__currentFrame)
		{
			return;
		}
		combine(__currentFrame, parentClip->__currentFrame);
		if(__currentFrame->alpha == 0 || !__currentFrame->visible)
		{
			__advanceTime(parentClipsDuration);
			return;
		}
		calcBoundingBox = (__currentFrame->handleEvents || calcBoundingBox) && engine->__hasTouchDeviceMessage();
	}
	if(__image)
	{
		__pixelRatioScale = (float)(scene->__view_pixel_ratio) / (float)(__image->pixelRatio);
		__currentFrame->scaleX *= __pixelRatioScale;
		__currentFrame->scaleY *= __pixelRatioScale;
		apply(__currentFrame, mv);
		__currentFrame->scaleX /= __pixelRatioScale;
		__currentFrame->scaleY /= __pixelRatioScale;
		String sequenceName = __currentFrame->spriteSequenceName;
		if(!sequenceName && parentClip && parentClip->__currentFrame)
		{
			sequenceName = parentClip->__currentFrame->spriteSequenceName;
		}
		if(!sequenceName)
		{
			__currentSequence = nullptr;
		}
		else if(!__currentSequence || __currentSequence->name != sequenceName)
		{
			__currentSequence = __image->getSequence(sequenceName);
			__currentSequence->sequenceStartTime = __currentTime;
		}
		if(__image->isSpriteSheet && __currentSequence)
		{
			int sequenceFrameIndex = __timeline->__paused ? 0 : (int)floor((float)((__currentTime - __currentSequence->sequenceStartTime)) / (float)(((float)(1000.0) / (float)(scene->__fps)))) % (int)__currentSequence->frames->size();
			int frame = (*__currentSequence->frames)[sequenceFrameIndex];
			ctx->drawFrame(scene, __image, frame, __currentFrame);
		}
		else
		{
			ctx->drawFrame(scene, __image, 0, __currentFrame);
		}
	}
	else
	{
		int childrenCound = __children->size();
		if(childrenCound > 0)
		{
			CocoClip* child;
			scene->__levelParents->push(this);
			if(__currentFrame)
			{
				apply(__currentFrame, mv);
			}
			for(int i = 0; i < childrenCound; i++)
			{
				mv->push();
				child = (*__children)[i];
				child->paint(ctx, scene, this, calcBoundingBox, level + 1);
				mv->pop();
			}
			scene->__levelParents->pop();
		}
	}
	if(this != scene->__root)
	{
		if(calcBoundingBox)
		{
			if(__image)
			{
				initBoundingBoxFromTexture(scene, mv, (float)(__image->textureCellWidth) / (float)(2), (float)(__image->textureCellHeight) / (float)(2), __pixelRatioScale);
			}
			else if(__children->size() > 0)
			{
				initBoundingBoxFromChildren(scene, mv);
			}
		}
		if(calcBoundingBox && __currentFrame->handleEvents)
		{
			DEVICE_MESSAGE* deviceMessage = engine->__peekDeviceMessage(DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_MASK);
			if(deviceMessage)
			{
				float x = (float)((deviceMessage->x0 - (float)(ctx->getWidth()) / (float)(2.0))) / (float)(scene->__view_scale);
				float y = (float)((deviceMessage->y0 - (float)(ctx->getHeight()) / (float)(2.0))) / (float)(scene->__view_scale);
				if(hitTest(x, y))
				{
					if(deviceMessage->type == DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_START)
					{
						switch(0)
						{
							case 0:
							{
								__touch_start_time = engine->__clock;
								__touch_start_point->x = deviceMessage->x0;
								__touch_start_point->y = deviceMessage->y0;
								this->OnTouchStart->x = deviceMessage->x0;
								this->OnTouchStart->y = deviceMessage->y0;
								dispatchEvent(this->OnTouchStart);
								break;
							}
						}
					}
					else if(deviceMessage->type == DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_MOVE)
					{
						switch(0)
						{
							case 0:
							{
								this->OnTouchMove->x = deviceMessage->x0;
								this->OnTouchMove->y = deviceMessage->y0;
								dispatchEvent(this->OnTouchMove);
								break;
							}
						}
					}
					else if(deviceMessage->type == DEVICE_MESSAGE_ENUM::MESSAGE_TOUCH_END)
					{
						switch(0)
						{
							case 0:
							{
								this->OnTouchEnd->x = deviceMessage->x0;
								this->OnTouchEnd->y = deviceMessage->y0;
								dispatchEvent(this->OnTouchEnd);
								if(abs(__touch_start_point->x - deviceMessage->x0) < 2 && abs(__touch_start_point->y - deviceMessage->y0) < 2)
								{
									trace((String("click: ") + __instanceName).c_str());
									dispatchEvent(this->OnClick);
									engine->__pushClicked(this);
								}
								__touch_start_time = 0;
								break;
							}
						}
					}
				}
			}
		}
		if(!__timeline->__paused)
		{
			if(__currentFrame->action)
			{
				(scene->*__currentFrame->action)();
			}
			if(__currentFrame->nextState)
			{
				engine->setNextState(__currentFrame->nextState);
			}
			if(__currentFrame->audio)
			{
				__currentFrame->audio->tick();
			}
			if(__currentFrame->audio)
			{
				if(__currentAudio && ((__currentFrame->audio != __currentAudio) || (__currentAudio->loops != 0)))
				{
					__currentAudio->reset();
				}
				__currentAudio = __currentFrame->audio;
			}
		}
		if(__currentAudio)
		{
			__currentAudio->tick();
			if(__currentAudio->ended())
			{
				__currentAudio->reset();
				__currentAudio = nullptr;
			}
		}
	}
	__advanceTime(parentClipsDuration);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::combine(CocoKeyFrame* F1, CocoKeyFrame* F2)
{
	if(!F2)
	{
		return;
	}
	if(!F1->filter)
	{
		F1->filter = F2->filter;
	}
	F1->red = F1->red * F2->red;
	F1->green = F1->green * F2->green;
	F1->blue = F1->blue * F2->blue;
	F1->alpha = F1->alpha * F2->alpha;
	F1->visible = F1->visible && F2->visible;
	F1->flipH = (F1->flipH && !F2->flipH) || (!F1->flipH && F2->flipH);
	F1->flipV = (F1->flipV && !F2->flipV) || (!F1->flipV && F2->flipV);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::apply(CocoKeyFrame* F, CocoMatrix* matrix)
{
	if(F->x != 0 || F->y != 0)
	{
		matrix->translate(F->x, F->y);
	}
	if(F->rotation != 0)
	{
		matrix->rotateZ(F->rotation * RADIANS);
	}
	if(F->scaleX != 1 || F->scaleY != 1)
	{
		matrix->scale(F->scaleX, F->scaleY);
	}
	if(F->pivotX != 0 || F->pivotY != 0)
	{
		matrix->translate(-F->pivotX,  -F->pivotY);
	}
}

////////////////////////////////////////////////////////////////////////////////////////////////////
bool CocoClip::hitTest(float wx, float wy)
{
	return ((((wx - __vABS_TOP_LEFT->X) * (__vABS_TOP_RIGHT->Y - __vABS_TOP_LEFT->Y) - (__vABS_TOP_RIGHT->X - __vABS_TOP_LEFT->X) * (wy - __vABS_TOP_LEFT->Y)) * ((wx - __vABS_BOTTOM_RIGHT->X) * (__vABS_BOTTOM_LEFT->Y - __vABS_BOTTOM_RIGHT->Y) - (__vABS_BOTTOM_LEFT->X - __vABS_BOTTOM_RIGHT->X) * (wy - __vABS_BOTTOM_RIGHT->Y))) > 0 && (((wx - __vABS_TOP_RIGHT->X) * (__vABS_BOTTOM_RIGHT->Y - __vABS_TOP_RIGHT->Y) - (__vABS_BOTTOM_RIGHT->X - __vABS_TOP_RIGHT->X) * (wy - __vABS_TOP_RIGHT->Y)) * ((wx - __vABS_BOTTOM_LEFT->X) * (__vABS_TOP_LEFT->Y - __vABS_BOTTOM_LEFT->Y) - (__vABS_TOP_LEFT->X - __vABS_BOTTOM_LEFT->X) * (wy - __vABS_BOTTOM_LEFT->Y))) > 0);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::initBoundingBoxFromTexture(CocoScene* scene, CocoMatrix* mv, float W2, float H2, float __pixelRatioScale)
{
	__mBBox->identity();
	__currentFrame->scaleX *= __pixelRatioScale;
	__currentFrame->scaleY *= __pixelRatioScale;
	apply(__currentFrame, __mBBox);
	__currentFrame->scaleX /= __pixelRatioScale;
	__currentFrame->scaleY /= __pixelRatioScale;
	__vBBoxVrtx->reset(-W2,  -H2, 0, 1);
	__vREL_TOP_LEFT = __mBBox->multiplyByVector(__vBBoxVrtx);
	__vABS_TOP_LEFT = mv->multiplyByVector(__vBBoxVrtx);
	__vBBoxVrtx->reset(W2,  -H2, 0, 1);
	__vREL_TOP_RIGHT = __mBBox->multiplyByVector(__vBBoxVrtx);
	__vABS_TOP_RIGHT = mv->multiplyByVector(__vBBoxVrtx);
	__vBBoxVrtx->reset(-W2, H2, 0, 1);
	__vREL_BOTTOM_LEFT = __mBBox->multiplyByVector(__vBBoxVrtx);
	__vABS_BOTTOM_LEFT = mv->multiplyByVector(__vBBoxVrtx);
	__vBBoxVrtx->reset(W2, H2, 0, 1);
	__vREL_BOTTOM_RIGHT = __mBBox->multiplyByVector(__vBBoxVrtx);
	__vABS_BOTTOM_RIGHT = mv->multiplyByVector(__vBBoxVrtx);
	__hasBoundingBox = true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
void CocoClip::initBoundingBoxFromChildren(CocoScene* scene, CocoMatrix* mv)
{
	__hasBoundingBox = false;
	if(__children->size() == 0)
	{
		return;
	}
	__vREL_TOP_LEFT->X = 100000;
	__vREL_TOP_RIGHT->X = -100000;
	__vREL_TOP_LEFT->Y = 100000;
	__vREL_BOTTOM_LEFT->Y = -100000;
	CocoClip* Child;
	int L = __children->size();
	for(int i = 0; i < L; i++)
	{
		Child = (*__children)[i];
		if(Child->__hasBoundingBox)
		{
			if(Child->__vREL_TOP_LEFT->X < __vREL_TOP_LEFT->X)
			{
				__vREL_TOP_LEFT->X = Child->__vREL_TOP_LEFT->X;
			}
			if(Child->__vREL_TOP_LEFT->X > __vREL_TOP_RIGHT->X)
			{
				__vREL_TOP_RIGHT->X = Child->__vREL_TOP_LEFT->X;
			}
			if(Child->__vREL_TOP_LEFT->Y < __vREL_TOP_LEFT->Y)
			{
				__vREL_TOP_LEFT->Y = Child->__vREL_TOP_LEFT->Y;
			}
			if(Child->__vREL_TOP_LEFT->Y > __vREL_BOTTOM_LEFT->Y)
			{
				__vREL_BOTTOM_LEFT->Y = Child->__vREL_TOP_LEFT->Y;
			}
			if(Child->__vREL_TOP_RIGHT->X < __vREL_TOP_LEFT->X)
			{
				__vREL_TOP_LEFT->X = Child->__vREL_TOP_RIGHT->X;
			}
			if(Child->__vREL_TOP_RIGHT->X > __vREL_TOP_RIGHT->X)
			{
				__vREL_TOP_RIGHT->X = Child->__vREL_TOP_RIGHT->X;
			}
			if(Child->__vREL_TOP_RIGHT->Y < __vREL_TOP_LEFT->Y)
			{
				__vREL_TOP_LEFT->Y = Child->__vREL_TOP_RIGHT->Y;
			}
			if(Child->__vREL_TOP_RIGHT->Y > __vREL_BOTTOM_LEFT->Y)
			{
				__vREL_BOTTOM_LEFT->Y = Child->__vREL_TOP_RIGHT->Y;
			}
			if(Child->__vREL_BOTTOM_LEFT->X < __vREL_TOP_LEFT->X)
			{
				__vREL_TOP_LEFT->X = Child->__vREL_BOTTOM_LEFT->X;
			}
			if(Child->__vREL_BOTTOM_LEFT->X > __vREL_TOP_RIGHT->X)
			{
				__vREL_TOP_RIGHT->X = Child->__vREL_BOTTOM_LEFT->X;
			}
			if(Child->__vREL_BOTTOM_LEFT->Y < __vREL_TOP_LEFT->Y)
			{
				__vREL_TOP_LEFT->Y = Child->__vREL_BOTTOM_LEFT->Y;
			}
			if(Child->__vREL_BOTTOM_LEFT->Y > __vREL_BOTTOM_LEFT->Y)
			{
				__vREL_BOTTOM_LEFT->Y = Child->__vREL_BOTTOM_LEFT->Y;
			}
			if(Child->__vREL_BOTTOM_RIGHT->X < __vREL_TOP_LEFT->X)
			{
				__vREL_TOP_LEFT->X = Child->__vREL_BOTTOM_RIGHT->X;
			}
			if(Child->__vREL_BOTTOM_RIGHT->X > __vREL_TOP_RIGHT->X)
			{
				__vREL_TOP_RIGHT->X = Child->__vREL_BOTTOM_RIGHT->X;
			}
			if(Child->__vREL_BOTTOM_RIGHT->Y < __vREL_TOP_LEFT->Y)
			{
				__vREL_TOP_LEFT->Y = Child->__vREL_BOTTOM_RIGHT->Y;
			}
			if(Child->__vREL_BOTTOM_RIGHT->Y > __vREL_BOTTOM_LEFT->Y)
			{
				__vREL_BOTTOM_LEFT->Y = Child->__vREL_BOTTOM_RIGHT->Y;
			}
		}
	}
	__vREL_TOP_RIGHT->Y = __vREL_TOP_LEFT->Y;
	__vREL_BOTTOM_LEFT->X = __vREL_TOP_LEFT->X;
	__vREL_BOTTOM_RIGHT->X = __vREL_TOP_RIGHT->X;
	__vREL_BOTTOM_RIGHT->Y = __vREL_BOTTOM_LEFT->Y;
	__vABS_TOP_LEFT = mv->multiplyByVector(__vREL_TOP_LEFT);
	__vABS_TOP_RIGHT = mv->multiplyByVector(__vREL_TOP_RIGHT);
	__vABS_BOTTOM_LEFT = mv->multiplyByVector(__vREL_BOTTOM_LEFT);
	__vABS_BOTTOM_RIGHT = mv->multiplyByVector(__vREL_BOTTOM_RIGHT);
	__mBBox->identity();
	apply(__currentFrame, __mBBox);
	__vREL_TOP_LEFT = __mBBox->multiplyByVector(__vREL_TOP_LEFT);
	__vREL_TOP_RIGHT = __mBBox->multiplyByVector(__vREL_TOP_RIGHT);
	__vREL_BOTTOM_LEFT = __mBBox->multiplyByVector(__vREL_BOTTOM_LEFT);
	__vREL_BOTTOM_RIGHT = __mBBox->multiplyByVector(__vREL_BOTTOM_RIGHT);
	__hasBoundingBox = true;
}
