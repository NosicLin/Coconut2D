"#export native";
"#export web";

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2014 www.coconut2D.org
 *
 * This is a private Framework of Coconut2D product and you should explicitly
 * own a license for using. Use of any portions or material related with this
 * Framework is prohibited. Please contact mobileFX for licensing inquiries.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */


"#include CocoClip.jspp";

// Slot Tile Symbol
struct CocoCasinoSlotTileSymbol
{
	tileName:String;
	minAppearancesToWin:Integer;
	isFreeSpin:Boolean;
	price1:Number;
	price2:Number;
	price3:Number;
	price4:Number;
}


// Slot Paytable
struct CocoCasinoSlotPaytable
{
	tiles:Array<CocoCasinoSlotTileSymbol>;
}

// Slot Line
struct CocoCasinoSlotLines
{
	line:Integer;
	combination:Array<Integer>;
}

//Slot Line Combinations
struct CocoCasinoSlotLineCompinations
{
	lines:Array<CocoCasinoSlotLines>;
}

// ==================================================================================================================================
//	   ______                 ______           _            _____ __      __
//	  / ____/___  _________  / ____/___ ______(_)___  ____ / ___// /___  / /_
//	 / /   / __ \/ ___/ __ \/ /   / __ `/ ___/ / __ \/ __ \\__ \/ / __ \/ __/
//	/ /___/ /_/ / /__/ /_/ / /___/ /_/ (__  ) / / / / /_/ /__/ / / /_/ / /_
//	\____/\____/\___/\____/\____/\__,_/____/_/_/ /_/\____/____/_/\____/\__/
//
// ==================================================================================================================================

class CocoCasinoSlot : CocoClip
{
	public var paytableSymbols: CocoCasinoSlotPaytable;
	published property CocoCasinoPayTable
	{
		function get():CocoCasinoSlotPaytable  { return paytableSymbols; }
		function set(v:CocoCasinoSlotPaytable) { paytableSymbols = v;  }
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public var TICKET:Array<Integer>;	//	Values returned from Server ([0]: Win/ Lose, [1]: Winnings/ 0)
	published var repeater:Integer;
	published var progressiveReelStops:Boolean;
	published var lineCombinations:CocoCasinoSlotLineCompinations;


	////////////////////////////////////////////////////////////////////////////////////////////////////
	public var minReelRepeats:Integer;
	published property MinReelRepetitions
 	{
 		function get():Integer  { return minReelRepeats; }
 		function set(v:Integer) { minReelRepeats = v; }
 	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public var maxReelRepeats:Integer;
	published property MaxReelRepetitions
 	{
 		function get():Integer  { return maxReelRepeats; }
 		function set(v:Integer) { maxReelRepeats = v; }
 	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public var numberOfReels:Integer;
	published property NumberOfReels
 	{
 		function get():Integer  { return numberOfReels; }
 		function set(v:Integer) { numberOfReels = v; }
 	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public  var reels:Array<CocoClip>;//Array<CocoCasinoSlotReel>;	// collections of all children with CocoCasinoClotReel class.
	private var bReelInitCompleted:Boolean;			// set to true when reel combinations are set
	private var reelEventCounter:Integer;
	private var No_Of_Tiles_In_Reel:Integer;		// if this is not a winning ticket select randomly the same tile for all to finish

	public  var freeSpinsMode:Boolean;
	private var freeSpinsCounter:Integer;
	private var currentFreeSpinSet:Integer;  		// Counts the FreeSpins given in a Row.
	public  var maxAllowedFreeSpinsInARow:Integer;			// Number of allowed FreeSpins while in FreeSpin mode.

	// Events
	public event OnSpinEnd();						// Notify whoever is listening that spin is over.


	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor(optional image:CocoImage):CocoClip(image)
	{
		TICKET		 				= new Array<Integer>;
		paytableSymbols 			= new CocoCasinoSlotPaytable();
		lineCombinations 			= new CocoCasinoSlotLineCompinations();
		reels 						= new Array<CocoClip>;//Array<CocoCasinoSlotReel>;

		progressiveReelStops 		= true;
		repeater 					= 2;
		minReelRepeats 				= 2;
		maxReelRepeats 				= 5;
		numberOfReels  				= 3;
		reelEventCounter			= 0;
		bReelInitCompleted			= false;

		No_Of_Tiles_In_Reel			= numberOfReels;

		freeSpinsMode				= false;
        freeSpinsCounter			= 0;

        // Allow up to 2 FreeSpins to happen in a row, that is plus one FreSpin while FreeSpin mode.
        maxAllowedFreeSpinsInARow	= 2;
        currentFreeSpinSet			= 0;

		InitLineCombinations();
		InitCocoCasinoPayTable();
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		delete TICKET;
		delete paytableSymbols;
		delete lineCombinations;
		delete reels;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public function InitCocoCasinoPayTable()
	{
		paytableSymbols.tiles  = new Array<CocoCasinoSlotTileSymbol>;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function InitLineCombinations()
	{
		lineCombinations.lines = new Array<CocoCasinoSlotLines>;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function InitReelSymbols(s:CocoCasinoSlotReel)
	{
		for( var i = paytableSymbols.tiles.size()-1; i>=0; i-- )
		{
			var obj:CocoCasinoTilePositionsInReel = new CocoCasinoTilePositionsInReel();
			obj.tileReferenceName    = paytableSymbols.tiles[i].tileName;
			obj.tileSymbolInChildren = new Array<Integer>;
			obj.tileInstanceName     = new Array<String>;
			obj.tilePositionInReel   = new Array<Integer>;
			s.ReelSymbolsCombinations.push(obj);
		}
		s.InitReelSymbols();
		No_Of_Tiles_In_Reel = s.No_Of_Tiles_In_Reel;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Spin()
	{
		var counter:Integer  = this.numberOfReels;
		if(!counter)
		{
			counter = this.getChildrenByClassName("CocoCasinoSlotReel").size();
			this.numberOfReels = counter;
		}
		if(!this.repeater) this.repeater = this.randomNumberInRange(minReelRepeats, maxReelRepeats);
		var line:Array<Integer> = this.lineCombinations.lines[this.TICKET[2]].combination;

		trace(this.TICKET.join("  -  "));
		var winReelSymbol:Array<String> = new Array<String>;
		winReelSymbol = getWinReelSymbolByPrice();

		if(!reels || !reels.size())
			reels = this.getChildrenByClassName("CocoCasinoSlotReel");

		for(var i:Integer=0; i<counter; i++)
    	{
    		var s:CocoCasinoSlotReel = CocoCasinoSlotReel(reels[i]);
    		if(!bReelInitCompleted) InitReelSymbols(s);
			s.addEventListener(s.OnReelSpinEnd, __CocoCasinoSlotSpinOver);
			s.stopReelOnTile(winReelSymbol[i], line[i]);
			s.Spin(this.repeater);
    		if(this.progressiveReelStops) this.repeater+=2;
    	}
    	bReelInitCompleted = true;
	}


	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public function randomNumberInRange(min:Integer, max:Integer):Integer
	{
		return Integer(Math.floor(Math.random() * Float(max - min + 1) + Float(min)));
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////
	public function __CocoCasinoSlotSpinOver(sender:CocoEventSource, e:CocoEvent) :Boolean
	{
		reelEventCounter++;
		if(this.reelEventCounter == this.numberOfReels)
		{
			for(var i:Integer=this.numberOfReels-1; i>=0; i--)
			{
				var s:CocoCasinoSlotReel = CocoCasinoSlotReel(this.__children[i]);
				s.removeEventListener(s.OnReelSpinEnd, __CocoCasinoSlotSpinOver);
			}
			this.reelEventCounter = 0;
			dispatchEvent(this.OnSpinEnd);
		}
		return false;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////
	private function getWinReelSymbolByPrice():Array<String>
	{
		// Returns an array with the name of symbol each reel should look for
		// and the lineOffset corresponding to the winning line combination.
		var randSymbolsComb		: Array<String> = new Array<String>;
		var winCombination		: Array<String> = new Array<String>;
		var pos					: Integer;
		var rmSymbols			: Integer;
		var nm					: String;

		var TICKET_price:Number 		= this.TICKET[1];
		var TICKET_line:Integer 		= this.TICKET[2];
		var TICKET_freeSpins:Integer 	= this.TICKET[3];
		var tiles:Array<CocoCasinoSlotTileSymbol> = this.paytableSymbols.tiles;

		// Make sure that there is not another row before or after that can produce a winning combination.
		// This is a designer problem. If I select a symbol with just one occurance in the reel, i cannot do
		// anything about it. NOT MY PROBLEM AS (A CLASS).
		//var otherTilesInColumn:Array<String> = new Array<String>;

		// Fill the temp array with all symbol names, to exclude same tiles selections in case of lose TICKET.
		var symbolsNames:Array<String> = new Array<String>;
		for(var i:Integer=0; i<tiles.size(); i++)
			symbolsNames.push(tiles[i].tileName);

		// Check if in FreeSpins mode
		if(freeSpinsMode)
		{
			freeSpinsCounter -= 1;
			if(freeSpinsCounter <= 0)
			{
				freeSpinsCounter   = 0;
				currentFreeSpinSet = 0;
				freeSpinsMode = false;
			}
		}
		//trace("freeSpinsMode =" + String(freeSpinsMode) + " freeSpinsCounter = " + String(freeSpinsCounter) + " maxAllowedFreeSpinsInARow " + String(maxAllowedFreeSpinsInARow) +  " currentFreeSpinSet " + String(currentFreeSpinSet) + " TICKET FREESPINs = "+TICKET[3]);

		if(!this.TICKET[0])
		{
			//randomly select tiles to show.
			for(var j=numberOfReels-1; j>=0; j--)
			{
				pos = Integer(Math.floor(Math.random() *  symbolsNames.size()));
				nm = symbolsNames[pos];
				symbolsNames.splice(pos, 1);
				winCombination.push(nm);
			}
			//trace(winCombination.join(", "));
			return winCombination;
		}

		for(var j=tiles.size()-1; j>=0; j--)
		{
			if(TICKET_freeSpins)
			{
				if(tiles[j].isFreeSpin)
				{
					nm = tiles[j].tileName;
					pos = findStringInArray(symbolsNames, nm);
					symbolsNames.splice(pos, 1);
					rmSymbols = this.numberOfReels - tiles[j].minAppearancesToWin;
					if(tiles[j].price2 && tiles[j].price2 == TICKET_price)
						rmSymbols -= 1;
					else if(tiles[j].price3 && tiles[j].price3 == TICKET_price)
						rmSymbols -= 2;
					if(!freeSpinsMode)
					{
						freeSpinsMode = true;
					    freeSpinsCounter = TICKET_price;
					    currentFreeSpinSet++;
					    //trace("INITIALIZATION  ---  freeSpinsMode =" + String(freeSpinsMode) + " freeSpinsCounter = " + String(freeSpinsCounter) + " maxAllowedFreeSpinsInARow " + String(maxAllowedFreeSpinsInARow) +  " currentFreeSpinSet " + String(currentFreeSpinSet) + " TICKET FREESPINs = "+String(TICKET[3]));
					}
					else
					{
						if(currentFreeSpinSet < maxAllowedFreeSpinsInARow)
						{
							freeSpinsCounter += TICKET_price;
							currentFreeSpinSet++;
					    	//trace("ADD NEW SPINS  ---  freeSpinsMode =" + String(freeSpinsMode) + " freeSpinsCounter = " + String(freeSpinsCounter) + " maxAllowedFreeSpinsInARow " + String(maxAllowedFreeSpinsInARow) +  " currentFreeSpinSet " + String(currentFreeSpinSet) + " TICKET FREESPINs = "+String(TICKET[3]));
						}
					}
					break;
				}
			}
			else
			{
				if(tiles[j].isFreeSpin) continue;

				nm = "";
				rmSymbols = 0;

				if(tiles[j].price1 == TICKET_price)
				{
					nm = tiles[j].tileName;
					rmSymbols = this.numberOfReels - tiles[j].minAppearancesToWin;
				}
				else if(tiles[j].price2 && tiles[j].price2 == TICKET_price)
				{
					nm = tiles[j].tileName;
					rmSymbols = this.numberOfReels - tiles[j].minAppearancesToWin - 1;
				}
				else if(tiles[j].price3 && tiles[j].price3 == TICKET_price)
				{
					nm = tiles[j].tileName;
					rmSymbols = this.numberOfReels - tiles[j].minAppearancesToWin - 2;
				}

				if(nm != "")
					randSymbolsComb.push(nm + ", " + String(rmSymbols));
			}
		}

		// If !FreeSpins
		if((!TICKET_freeSpins) && (randSymbolsComb.size()>0))
		{
			// If there are more that one symbols that can win the same price, randomly select one of them.
			var r:Integer = 0;
			if(randSymbolsComb.size() > 1) r = Integer(Math.floor(Math.random() * randSymbolsComb.size()));
			randSymbolsComb = randSymbolsComb[r].split(", ");
			nm = randSymbolsComb[0];
			pos = findStringInArray(symbolsNames, nm);
			symbolsNames.splice(pos, 1);
			rmSymbols = Integer(randSymbolsComb[1]);
		}
		winCombination = selectRemainingSymbols(numberOfReels, rmSymbols, symbolsNames, nm);
		return winCombination;
	}

	//--------------------------------------------------------------------------------------------
	private function selectRemainingSymbols(numberOfReels:Integer, rmSymbols:Integer, symbolsNms:Array<String>, winSymbolName:String):Array<String>
	{
		var combinations : Array<String> = new Array<String>;
		var pos			 : Integer;
		var nm			 : String = "";

		for(var j:Integer=0; j<numberOfReels-rmSymbols; j++)
			combinations.push(winSymbolName);

		if(rmSymbols)
		{
			for(var j:Integer=combinations.size(); j<numberOfReels; j++)
			{
				pos = Integer(Math.floor(Math.random() * symbolsNms.size()));
				nm = symbolsNms[pos];
				symbolsNms.splice(pos, 1);
				combinations.push(nm);
			}
		}
		//trace(combinations.join(", "));
		return combinations;
	}

	private function findStringInArray(arr:Array<String>, v:String):Integer
	{
		for(var i=arr.size()-1; i>=0; i--)
		{
			if(arr[i]==v) return i;
		}
		return -1;
	}

}