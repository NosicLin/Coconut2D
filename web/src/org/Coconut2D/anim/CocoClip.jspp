//@compile{true} 

//@include{WebGLRenderingContext.jspp}
//@include{CocoMatrix.jspp}
//@include{CocoImage.jspp}
//@include{CocoSound.jspp}
//@include{CocoTimeline.jspp}
                     
/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013 www.coconut2D.org
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.   
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	   ______                 _________     
//	  / ____/___  _________  / ____/ (_)___ 
//	 / /   / __ \/ ___/ __ \/ /   / / / __ \
//	/ /___/ /_/ / /__/ /_/ / /___/ / / /_/ /
//	\____/\____/\___/\____/\____/_/_/ .___/ 
//	                               /_/      
// ==================================================================================================================================

class CocoClip
{           
	public var __instanceName:String;					
	public var __image:CocoImage;						
	public var __audio:CocoSound;						
	public var __symbolLoop:COCO_CLIP_SYMBOL_LOOP_ENUM;	
	public var __children:Array<CocoClip>;				
	public var __currentSequence:CocoSequence;
	public var __currentSequenceFrameIndex:Integer;		
	public var __timeline:CocoTimeline;					
	public var __parent:CocoClip;						
	public var __firstTickTime:Float;					
	public var __currentFrame:CocoKeyFrame;				
	public var __hasBoundingBox:Boolean;					
	public var __vTOP_LEFT:CocoVector;					
	public var __vTOP_RIGHT:CocoVector;					
	public var __vBOTTOM_LEFT:CocoVector;				
	public var __vBOTTOM_RIGHT:CocoVector;					
	public var __childWithMaxTimelineDuration:CocoClip;	
			
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor(image:CocoImage, audio:CocoSound, sequence:String, mask:CocoImage)
	{
		__symbolLoop					= COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_CONTINUOUS;
		__currentSequenceFrameIndex		= 0;
		__timeline						= new CocoTimeline();
		__parent						= null;    	                                        	
		__firstTickTime					= -1.0;
		__currentFrame					= null;				                                        	
		__hasBoundingBox				= false;	
		__vTOP_LEFT						= new CocoVector();
		__vTOP_RIGHT					= new CocoVector();
		__vBOTTOM_LEFT					= new CocoVector();
		__vBOTTOM_RIGHT					= new CocoVector();  		
		__childWithMaxTimelineDuration	= null;
		__currentSequence				= null;
		
		if(image) __image = image;
		if(audio) __audio = audio;
		if(image && sequence) __currentSequence = image.getSequence(sequence);		
	}  
							
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function reset()
	{
		__currentFrame = null;
	    __firstTickTime = -1;
	    __timeline.reset();

	    for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			__children[i].reset();
	    }	    
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function addChild(clipInstance:CocoClip) :CocoClip
	{
	    if(!clipInstance) return null;
	    if(!clipInstance.__instanceName) throw "Invalid instance name.";
        __children.push(clipInstance);	    
	    normalize();
	    return clipInstance;	
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function removeChild(clipInstance:CocoClip) :CocoClip
	{
	    if(!clipInstance) return null;
	    __children.splice( getChildIndex(clipInstance), 1);
	    normalize();
	    return clipInstance;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function normalize()
	{
		// Find clip with max timeline duration.		
	    __childWithMaxTimelineDuration = null;
	    for(var i:Integer =__children.size()-1; i>=0; i--)
	    {
	    	if(!__childWithMaxTimelineDuration) { __childWithMaxTimelineDuration = __children[i]; continue; }
	        if(__children[i].__timeline.__durationInTime > __childWithMaxTimelineDuration.__timeline.__durationInTime) 
				__childWithMaxTimelineDuration = __children[i];
	    }	
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildByName(instanceName:String) :CocoClip
	{    
	    for(var i:Integer =__children.size()-1; i>=0; i--)
			if(__children[i].__instanceName==instanceName)
				return __children[i];
		return null;
	}
		
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildIndex(child:CocoClip) :Integer
	{
	    if(child)
		    for(var i:Integer =__children.size()-1; i>=0; i--)
				if(__children[i]==child)
					return i;
		return -1;
	} 
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoFrameByName(LabelName:String, pause:Boolean, deep:Boolean) :Boolean
	{
		var Label:CocoTimeLabel = __timeline.findLabelByName(LabelName);
		if(!Label) return false;
		return gotoFrameByIndex(Label.frameIndex);
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoFrameByIndex(FrameIndex:Integer, pause:Boolean, deep:Boolean) :Boolean
	{
		var clip:CocoClip;
		for (var i:Integer = __children.size() - 1; i >= 0; i--)
		{
			clip = __children[i];
			if (FrameIndex == COCO_STOP_ON_CURRENT_FRAME)
			{
				clip.__timeline.jumpBy(0, pause);
			}
			else
			{
				var frames:Integer = (FrameIndex - clip.__currentFrame.frameIndex);
				clip.__timeline.jumpBy(frames, pause);
			}
			if (deep)
			{
				clip.gotoFrameByIndex(COCO_STOP_ON_CURRENT_FRAME, pause, deep);
			}
		}
		return true;
	};
				
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function render(gl:WebGLRenderingContext, scene:CocoScene, parentClip:CocoClip, picking:Boolean)
	{        
		// Get scene current time and add timeline skipTime (used in timeline jumps such as stop(), gotoAndPlay(), gotoAndStop() )		                                    
		var currentTime:Float = scene.__currentTime + __timeline.__skipTime; 

		// Keep track of first tick time.		
		if(__firstTickTime == -1) __firstTickTime = currentTime;//scene.__currentTime;		
		
		// Calculate the parent timeline duraction in time from its children.
		// Note: the parent timeline might have only one KeyFrame but the actual length is defined by the max timeline size of each children.		
		var parentClipsDuration:Float = (parentClip ? parentClip.__childWithMaxTimelineDuration.__timeline.__durationInTime : __timeline.__durationInTime);
		
		// Calculate this clip's LoopTime which is the projection of this clip's timeline to its parent's timeline.
		var clippingTime:Float = Math.floor((currentTime - __firstTickTime) / parentClipsDuration) * parentClipsDuration;
		
		// Adjust LoopTime start.
		var loopTime:Float = (currentTime - __firstTickTime) - clippingTime;					
		
        // Take into account time sync between this clip and its parent.
		switch(__symbolLoop)
		{
			case COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_CONTINUOUS:
			    __currentFrame = __timeline.interpolateByTime(loopTime);
				break;     
				
			case COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_SYNCHRONIZED_WITH_PARENT:
			    __currentFrame = __timeline.interpolateByTime(loopTime); // TODO
				break; 
				
			case COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_ONCE:
			    if(clippingTime > 0) 
			    	__currentFrame = __timeline.__lastKeyFrame.clone();
			    else
			    	__currentFrame = __timeline.interpolateByTime(loopTime); 
				break;
		}
		
		// Combine parent clip currentframe values with this clip's interpolated frame values.
		if(parentClip)                                      
		{
			 __currentFrame.combine(parentClip.__currentFrame);
			
			// If a child handles events and requires a bounding box calculation 
			// then the entire parent-child chain needs to calculate bounding box.
			if(__currentFrame.calcBoundingBox) 
				parentClip.__currentFrame.calcBoundingBox = true;
		}
			
		// If current frame is visible, render this clip and its children.
		if(__currentFrame.alpha != 0 && __currentFrame.visible)
		{			
			if(__image)
			{                                         
				var c = scene.__view_pixel_ratio / __image.pixelRatio;
				__currentFrame.scaleX *= c;
				__currentFrame.scaleY *= c;
				__currentFrame.apply(scene.__modelViewMatrix);											
				__currentFrame.scaleX /= c;
				__currentFrame.scaleY /= c;
				
				if(__image.isSpriteSheet && __currentSequence)
				{
					// Render animation sequence.
					__currentSequenceFrameIndex = __timeline.__paused ? 0 : Math.floor((currentTime - __firstTickTime) / GLOBAL_FPS) % __currentSequence.frames.size();
					var frame = __currentSequence.frames[__currentSequenceFrameIndex];
					scene.drawFrame(gl, __image, frame, __currentFrame.alpha);
				}
				else
				{
					// Render a standard image.					
					scene.drawFrame(gl, __image, 0,  __currentFrame.alpha);	
				}			
			} 
			else
			{			
				// Render Children				
				scene.__levelParents.push(this);				
				__currentFrame.apply(scene.__modelViewMatrix);
				for (var i = 0, L = __children.size(); i < L; i++)
				{
					scene.__modelViewMatrix.push();
					__children[i].render(gl, scene, this, picking);
					scene.__modelViewMatrix.pop();
				}
				scene.__levelParents.pop();
			}			
		}
		 		
		// Execute KeyFrame action callback.  
		if(!__timeline.__paused && __currentFrame.action)
		{			
			this.__parent = parentClip;
			__currentFrame.execute(gl, currentTime, loopTime, scene, this);
			this.__parent = null;		
		}		
	} 
}




