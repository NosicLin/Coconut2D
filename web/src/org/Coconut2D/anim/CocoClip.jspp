//@compile{true}
//@include{WebGL.js,CocoTimeline.jspp}

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013 www.coconut2D.org
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.   
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	   ______                 _________     
//	  / ____/___  _________  / ____/ (_)___ 
//	 / /   / __ \/ ___/ __ \/ /   / / / __ \
//	/ /___/ /_/ / /__/ /_/ / /___/ / / /_/ /
//	\____/\____/\___/\____/\____/_/_/ .___/ 
//	                               /_/      
// ==================================================================================================================================

class CocoClip
{           
	public var __instanceName:String					= null;
	public var __image:CocoImage						= null;
	public var __mask:CocoImage							= null;
	public var __audio:CocoSound						= null;
	public var __symbolLoop:COCO_CLIP_SYMBOL_LOOP_ENUM	= COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_CONTINUOUS;
	public var __childrenCount:Number					= 0;
	public var __children:Object						= {};	
	public var __currentSequenceName:String				= null;
	public var __currentSequenceFrameIndex:Number		= 0;
	public var __currentFrame:CocoKeyFrame				= null;
	public var __timeline:CocoTimeline					= null;
	public var __firstTickTime:Number					= 0.0;
	public var __parent:CocoClip						= null;
			
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor(image:CocoImage, audio:CocoSound, sequence:String, mask:CocoImage)
	{
		__timeline = new CocoTimeline(); 
		if(image) __image = image;
		if(audio) __audio = audio;
		if(sequence) __currentSequenceName = sequence;	
	}  
				
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function children() :Array
	{		
		var children:Array = [];
		var vClip:String;
		for(vClip in __children)
			children.push(__children[vClip]);	
	    return children;   
	}  
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function childrenMaxFrameIndex() :Number
	{      
		var vClip:String, ci:CocoClip, T:Number = 0;
	    for(vClip in __children)
		{
			ci = __children[vClip] || null;
	        if(ci.__timeline.__lastframeIndex > T) 
	            T = ci.__timeline.__lastframeIndex;
	    }
	    return T;	    	    
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function childrenMaxTimelineDuration() :Number
	{
	    var vClip:String, ci:CocoClip, T:Number = 0;
	    for(vClip in __children)
		{
			ci = __children[vClip]; 			
	        if(ci.__timeline.__durationInTime > T)
	            T = ci.__timeline.__durationInTime;
	    }
	    return T;
	}
		
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function addChild(clipInstance:CocoClip) :CocoClip
	{
	    if(!clipInstance) return null;
	    if(!clipInstance.__instanceName) throw "Invalid instance name.";
	    if(__children[clipInstance.__instanceName]) throw "Instance " + clipInstance.__instanceName + " already exists.";
	    __children[clipInstance.__instanceName] = clipInstance;
	    __childrenCount++;
	    return clipInstance;	
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function removeChild(clipInstance:CocoClip) :CocoClip
	{
	    if(!clipInstance) return null;
	    if(!clipInstance.__instanceName) throw "Invalid instance name.";
	    if(!__children[clipInstance.__instanceName]) throw "Instance " + clipInstance.__instanceName + " does not exist in this parent.";
	    __children[clipInstance.__instanceName] = null;
	    __childrenCount--;
	    return clipInstance;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildByName(instanceName:String) :CocoClip
	{    
		return __children[instanceName] || null;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildByIndex(index:Number) :CocoClip
	{        
		if(!(index >= 0 && index < __childrenCount)) return null;
		var arr:Array = children();
		return arr[index];
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildIndex(child:CocoClip) :Number
	{
	    if(child)
	    {
	    	var vClip:String, index:Number = -1;
			for(vClip in __children)
			{
				index++;
				if(__children[vClip]==child)
					return index;
			}
		}
		return -1;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function isParentOf(child:CocoClip) :Boolean
	{
	    if(!child) return false;
	    
	    if(__children[child.__instanceName]) 
	        return true;        
	     
	    var vClip:String, clip:CocoClip;
	    for(vClip in __children)
	    {
	        clip = __children[vClip] || null;
	        if(clip && clip.isParentOf(child))
				return true;
	    }
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function moveChildToIndex(child:CocoClip, newIndex:Number) :Boolean
	{  
		var a=5;
		
	    if(newIndex < 0) return false;
	    if(newIndex > __childrenCount) return false;
	    
	    var oldIndex:Number = getChildIndex(child);
	    if(oldIndex = newIndex) return false;
	    
	    var arr:Array = children();    
	    arr.splice(oldIndex, 1);
	    
	    if(newIndex + 1 > arr.length) 
	    {
	        arr.push(child);
	    } 
	    else 
	    {
	        arr.insertBefore(child, newIndex);
	    }
	    
	    __children = {};    
	    var clip:CocoClip;
	    var i:Number;
	    for(i=0; i<arr.legnth; i++)
	    {
	    	clip = arr[i];
	        __children[clip.__instanceName] = clip;
	    }
	    
	    return true;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoFrame(LabelNameOrFrameIndex, pause:Boolean, deep:Boolean) :Boolean
	{
		// Resolve LabelNameOrFrameIndex to a FrameIndex number.		
		var FrameIndex:Number = parseInt(LabelNameOrFrameIndex);
		if(isNaN(FrameIndex))
		{
			var Label:CocoTimeLabel = __timeline.findLabelByName(LabelNameOrFrameIndex);
			if(!Label) return false;
			FrameIndex = Label.frameIndex;				
		}

		// Loop on children to jump timeline head to desired position.		
		var vClip:String;
		var clip:CocoClip;				    		
		for(vClip in __children)
		{					
			clip = __children[vClip];	
						
			if(FrameIndex==COCO_STOP_ON_CURRENT_FRAME)
			{
				// Special case to stop on current frame.
				clip.__timeline.jumpBy(0, pause);	
			}
			else
			{
				// Calculate difference between current frame and jump frame.
				var frames:Number = (FrameIndex - clip.__currentFrame.frameIndex);
				clip.__timeline.jumpBy(frames, pause);
			}
			 
			// Deep works for stopping / resuming children with no timeline jumping.
			// Otherwise if you need time adjustment for childrent, use the API.
			if(deep)
			{
				clip.gotoFrame(COCO_STOP_ON_CURRENT_FRAME, pause, deep);
			}			
		}
		
		return true;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function render(gl:WebGLRenderingContext, scene:CocoScene, parentClip:CocoClip)
	{        
		// Get scene current time and add timeline skipTime (used in timeline jumps such as stop(), gotoAndPlay(), gotoAndStop() )		                                    
		var currentTime:Number = scene.__currentTime + __timeline.__skipTime;

		// Keep track of first tick time.		
		if(__firstTickTime == -1) __firstTickTime = currentTime;		
		
		// Calculate the parent timeline duraction in time from its children.
		// Note: the parent timeline might have only one KeyFrame but the actual length is defined by the max timeline size of each children.
		var parentClipsDuration:Number = (parentClip ? parentClip.childrenMaxTimelineDuration() : __timeline.__durationInTime);

		// Calculate this clip's LoopTime which is the projection of this clip's timeline to its parent's timeline.
		var clippingTime:Number = Math.floor((currentTime - __firstTickTime) / parentClipsDuration) * parentClipsDuration;
		
		// Adjust LoopTime start.
		var loopTime:Number = (currentTime - __firstTickTime) - clippingTime;					
        
        // Take into account time sync between this clip and its parent.
		switch(__symbolLoop)
		{
			case COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_CONTINUOUS:
			    __currentFrame = __timeline.interpolateByTime(loopTime);
				break;     
				
			case COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_SYNCHRONIZED_WITH_PARENT:
			    __currentFrame = __timeline.interpolateByTime(loopTime); // TODO
				break; 
				
			case COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_ONCE:
			    if(clippingTime > 0) 
			    	__currentFrame = __timeline.__lastKeyFrame.clone();
			    else
			    	__currentFrame = __timeline.interpolateByTime(loopTime); 
				break;
		}
		
		// Combine parent clip currentframe values with this clip's interpolated frame values.
		if(parentClip)
			 __currentFrame.combine(parentClip.__currentFrame);
	
		// Apply this clip's current frame values to modelview matrix.
		__currentFrame.apply(scene.__modelViewMatrix);
		scene.updateModelViewMatrix(gl);

		// If we are visible, render this clip and its children.
		if(__currentFrame.alpha != 0 && __currentFrame.visible)
		{			
			if(__image)
			{								
				// If this clip is a primitive (low-level clip with an image) then render the image.				
				if(__image.isSpriteSheet()) 
				{   
					// If the image is Spritesheet then render its current Animation Sequence.					
					if(!__currentSequenceName)
					{    
						var s:String;
						for(s in __image.sequences)
						{
							__currentSequenceName = s;
							break;
						}
					} 
					var seq:CocoSequence = __image.sequences[__currentSequenceName];				
					__currentSequenceFrameIndex = __timeline.__paused ? 0 : Math.floor(((currentTime - __firstTickTime) / GLOBAL_FPS)) % seq.frames.length;
					var frame:Number = seq.frames[__currentSequenceFrameIndex];
					__image.drawFrame(gl, scene.__glProgram, frame, __currentFrame.alpha);
				} 
				else
				{
					// Render a standard image.					
					__image.drawFrame(gl, scene.__glProgram, 0,  __currentFrame.alpha);	
				}			
			} 
			else
			{			
				// Render Children			    
				var c:String;
				var ci:CocoClip;
				scene.__levelParents.push(this);
				for(c in __children)
				{	
					scene.__modelViewMatrix.push();		
					ci = __children[c];
					ci.render(gl, scene, this);
					scene.__modelViewMatrix.pop();			
				} 
				scene.__levelParents.pop();
			}
		}
		
		// Execute KeyFrame action callback.
		this.__parent = parentClip;
		__currentFrame.execute(gl, currentTime, loopTime, scene, this);
		this.__parent = null;		
	}
}











