"#export native"
"#export web"

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2014 www.coconut2D.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	   ______				  _________
//	  / ____/___  _________  / ____/ (_)___
//	 / /   / __ \/ ___/ __ \/ /   / / / __ \
//	/ /___/ /_/ / /__/ /_/ / /___/ / / /_/ /
//	\____/\____/\___/\____/\____/_/_/ .___/
//								   /_/
// ==================================================================================================================================

"#include WebGLRenderingContext.jspp"
"#include CocoMatrix.jspp"
"#include CocoImage.jspp"
"#include CocoAudio.jspp"
"#include CocoTimeline.jspp"

class CocoClip : EventTarget
{
	public var __instanceName:String;
	public var __image:CocoImage;
	public var __audio:CocoAudio;
	public var __symbolLoop:COCO_CLIP_SYMBOL_LOOP_ENUM;
	public var __children:Array<CocoClip>;
	public var __currentSequence:CocoSequence;
	public var __currentSequenceFrameIndex:Integer;
	public var __timeline:CocoTimeline;
	public var __parent:CocoClip;
	public var __firstTickTime:Float;
	public var __currentFrame:CocoKeyFrame;
	public var __hasBoundingBox:Boolean;
	public var __vABS_TOP_LEFT:CocoVector;
	public var __vABS_TOP_RIGHT:CocoVector;
	public var __vABS_BOTTOM_LEFT:CocoVector;
	public var __vABS_BOTTOM_RIGHT:CocoVector;
	public var __vREL_TOP_LEFT:CocoVector;
	public var __vREL_TOP_RIGHT:CocoVector;
	public var __vREL_BOTTOM_LEFT:CocoVector;
	public var __vREL_BOTTOM_RIGHT:CocoVector;
	public var __vTemp:CocoVector;
	public var __mTemp:CocoMatrix;
	public var __childWithMaxTimelineDuration:CocoClip;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor(optional image:CocoImage, optional audio:CocoAudio, optional sequence:String)
	{
		__symbolLoop					= COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_CONTINUOUS;
		__currentSequenceFrameIndex		= 0;
		__timeline						= new CocoTimeline();
		__parent						= null;
		__firstTickTime					= -1.0;
		__currentFrame					= null;
		__hasBoundingBox				= false;
		__vABS_TOP_LEFT					= new CocoVector();
		__vABS_TOP_RIGHT				= new CocoVector();
		__vABS_BOTTOM_LEFT				= new CocoVector();
		__vABS_BOTTOM_RIGHT				= new CocoVector();
		__vREL_TOP_LEFT					= new CocoVector();
		__vREL_TOP_RIGHT				= new CocoVector();
		__vREL_BOTTOM_LEFT				= new CocoVector();
		__vREL_BOTTOM_RIGHT				= new CocoVector();
		__vTemp							= new CocoVector();
		__mTemp							= new CocoMatrix();
		__childWithMaxTimelineDuration	= null;
		__currentSequence				= null;

		__image = image;
		__audio = audio;

		if(image && sequence) __currentSequence = image.getSequence(sequence);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		delete __image;
		delete __audio;
		delete __children;
		delete __timeline;
		delete __vABS_TOP_LEFT;
		delete __vABS_TOP_RIGHT;
		delete __vABS_BOTTOM_LEFT;
		delete __vABS_BOTTOM_RIGHT;
		delete __vREL_TOP_LEFT;
		delete __vREL_TOP_RIGHT;
		delete __vREL_BOTTOM_LEFT;
		delete __vREL_BOTTOM_RIGHT;
		delete __vTemp;
		delete __mTemp;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function prepare(scene:CocoScene)
	{
		__timeline.prepare(scene, this);
		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			__children[i].prepare(scene);
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function reset()
	{
		if(__currentFrame) delete __currentFrame;
		__currentFrame = null;
		__firstTickTime = -1;
		__timeline.reset();

		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			__children[i].reset();
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function addChild(clipInstance:CocoClip) :CocoClip
	{
		if(!clipInstance) return null;
		if(!clipInstance.__instanceName) throw "Invalid instance name.";
		__children.push(clipInstance);
		normalize();
		return clipInstance;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function removeChild(clipInstance:CocoClip) :CocoClip
	{
		if(!clipInstance) return null;
		__children.splice( getChildIndex(clipInstance), 1);
		normalize();
		return clipInstance;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function normalize()
	{
		// Find clip with max timeline duration.
		__childWithMaxTimelineDuration = null;
		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			if(!__childWithMaxTimelineDuration)
			{
				__childWithMaxTimelineDuration = __children[i];
				continue;
			}
			if(__children[i].__timeline.__durationInTime > __childWithMaxTimelineDuration.__timeline.__durationInTime)
			{
				__childWithMaxTimelineDuration = __children[i];
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildByName(instanceName:String) :CocoClip
	{
		for(var i:Integer =__children.size()-1; i>=0; i--)
		{
			if(__children[i].__instanceName==instanceName)
			{
				return __children[i];
			}
		}
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getChildIndex(child:CocoClip) :Integer
	{
		if(child)
		{
			for(var i:Integer =__children.size()-1; i>=0; i--)
			{
				if(__children[i]==child)
				{
					return i;
				}
			}
		}
		return -1;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoFrameByName(LabelName:String, pause:Boolean, deep:Boolean) :Boolean
	{
		var Label:CocoTimeLabel = __timeline.findLabelByName(LabelName);
		if(!Label) return false;
		return gotoFrameByIndex(Label.frameIndex, pause, deep);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoFrameByIndex(FrameIndex:Integer, pause:Boolean, deep:Boolean) :Boolean
	{
		var clip:CocoClip;
		for (var i:Integer = __children.size() - 1; i >= 0; i--)
		{
			clip = __children[i];
			if (FrameIndex == COCO_STOP_ON_CURRENT_FRAME)
			{
				clip.__timeline.jumpBy(0, pause);
			}
			else
			{
				var frames:Integer = (FrameIndex - clip.__currentFrame.frameIndex);
				clip.__timeline.jumpBy(frames, pause);
			}
			if (deep)
			{
				clip.gotoFrameByIndex(COCO_STOP_ON_CURRENT_FRAME, pause, deep);
			}
		}
		return true;
	};

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function paint(gl:WebGLRenderingContext, scene:CocoScene, parentClip:CocoClip)
	{
		// Get scene current time + timeline skipTime (used in timeline jumps such as stop(), gotoAndPlay(), gotoAndStop() )
		var __currentTime:Float = scene.__currentTime + __timeline.__skipTime;

		// Keep track of first tick time.
		if(__firstTickTime == -1) __firstTickTime = __currentTime;

		// Calculate the parent timeline duraction in time from its children.
		// Note: the parent timeline might have only one KeyFrame but the actual length is defined by the max timeline size of each children.
		var parentClipsDuration:Float = (parentClip ? parentClip.__childWithMaxTimelineDuration.__timeline.__durationInTime : __timeline.__durationInTime);

		// Calculate this clip's LoopTime which is the projection of this clip's timeline to its parent's timeline.
		var clippingTime:Float = Math.floor((__currentTime - __firstTickTime) / parentClipsDuration) * parentClipsDuration;

		// Adjust LoopTime start.
		var __loopTime:Float = (__currentTime - __firstTickTime) - clippingTime;

		// Delete previous __currentFrame if not paused.
		if(!__timeline.__paused && __currentFrame) delete __currentFrame;

		// Take into account time sync between this clip and its parent.
		switch(__symbolLoop)
		{
			case COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_CONTINUOUS:
				__currentFrame = __timeline.interpolateByTime(__loopTime);
				break;

			case COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_SYNCHRONIZED_WITH_PARENT:
				__currentFrame = __timeline.interpolateByTime(__loopTime); // TODO
				break;

			case COCO_CLIP_SYMBOL_LOOP_ENUM.CLIP_SYMBOL_LOOP_ONCE:
				if(clippingTime > 0)
					__currentFrame = __timeline.lastKeyFrame().clone();
				else
					__currentFrame = __timeline.interpolateByTime(__loopTime);
				break;
		}

		// Combine parent clip currentframe values with this clip's interpolated frame values.
		if(parentClip)
		{
			 __currentFrame.combine(parentClip.__currentFrame);

			// If a child handles events and requires a bounding box calculation
			// then the entire parent-child chain needs to calculate bounding box.
			if(__currentFrame.calcBoundingBox)
				parentClip.__currentFrame.calcBoundingBox = true;
		}

		// If current frame is visible, render this clip and its children.
		if(__currentFrame.alpha != 0 && __currentFrame.visible)
		{
			if(__image)
			{
				__currentFrame.scaleX *= __image.__pixelRatioScale;
				__currentFrame.scaleY *= __image.__pixelRatioScale;
				__currentFrame.apply(scene.__modelViewMatrix);
				__currentFrame.scaleX /= __image.__pixelRatioScale;
				__currentFrame.scaleY /= __image.__pixelRatioScale;

				if(__image.isSpriteSheet && __currentSequence)
				{
					// Render animation sequence.
					__currentSequenceFrameIndex = __timeline.__paused ? 0 : Math.floor((__currentTime - __firstTickTime) / (1000.0 / scene.__fps)) % __currentSequence.frames.size();
					var frame:Integer = __currentSequence.frames[__currentSequenceFrameIndex];
					scene.drawFrame(gl, __image, frame, __currentFrame.alpha);
				}
				else
				{
					// Render a standard image.
					scene.drawFrame(gl, __image, 0,  __currentFrame.alpha);
				}
			}
			else
			{
				// Render Children
				scene.__levelParents.push(this);
				__currentFrame.apply(scene.__modelViewMatrix);
				for (var i:Integer = 0, L:Integer = __children.size(); i < L; i++)
				{
					scene.__modelViewMatrix.push();
					__children[i].paint(gl, scene, this);
					scene.__modelViewMatrix.pop();
				}
				scene.__levelParents.pop();
			}

			// Handle touch event
			if(__currentFrame.alpha != 0 && __currentFrame.visible && engine.__deviceEvent && this!=scene.__root)// && __currentFrame.calcBoundingBox)
			{
				// Calculate bounding box vertices
				if(__image)
					initBoundingBoxFromTexture(scene, __image.textureCellWidth / 2, __image.textureCellHeight / 2);
				else if(__children.size()>0)
					initBoundingBoxFromChildren(scene);

				// Point in quad?
				if(!__image)
				{
		   	        var x = (engine.__deviceEvent.__clientX - gl.canvas.width / 2.0) / scene.__view_scale;
					var y = (engine.__deviceEvent.__clientY - gl.canvas.height / 2.0) / scene.__view_scale;

					if(hitTest(x,y))
		   	        {
		   	        	//enigne.signalEvent(this, new CocoTouchEvent(engine.__deviceEvent.type, x, y) );
		   	        	drawBoundingBox(scene, gl);
		   	        }
				}
			}
		}

		// Take care of audio loops
		__audio && __audio.tick();

		// Execute KeyFrame action callback.
		if(!__timeline.__paused && (__currentFrame.action || __currentFrame.nextState))
		{
			this.__parent = parentClip;
			__currentFrame.execute(gl, __currentTime, __loopTime, scene, this);
			this.__parent = null;
		}

		// Update Cursor Variables
		if(__childWithMaxTimelineDuration && __childWithMaxTimelineDuration.__currentFrame && __childWithMaxTimelineDuration.__currentFrame.frameIndex == __childWithMaxTimelineDuration.__timeline.lastKeyFrame().frameIndex)
		{
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function hitTest(wx:Float, wy:Float) :Boolean
	{
		return ((((wx - __vABS_TOP_LEFT.X) * (__vABS_TOP_RIGHT.Y - __vABS_TOP_LEFT.Y) - (__vABS_TOP_RIGHT.X - __vABS_TOP_LEFT.X) * (wy - __vABS_TOP_LEFT.Y)) * ((wx - __vABS_BOTTOM_RIGHT.X) * (__vABS_BOTTOM_LEFT.Y - __vABS_BOTTOM_RIGHT.Y) - (__vABS_BOTTOM_LEFT.X - __vABS_BOTTOM_RIGHT.X) * (wy - __vABS_BOTTOM_RIGHT.Y))) > 0
			&& (((wx - __vABS_TOP_RIGHT.X) * (__vABS_BOTTOM_RIGHT.Y - __vABS_TOP_RIGHT.Y) - (__vABS_BOTTOM_RIGHT.X - __vABS_TOP_RIGHT.X) * (wy - __vABS_TOP_RIGHT.Y)) * ((wx - __vABS_BOTTOM_LEFT.X) * (__vABS_TOP_LEFT.Y - __vABS_BOTTOM_LEFT.Y) - (__vABS_TOP_LEFT.X - __vABS_BOTTOM_LEFT.X) * (wy - __vABS_BOTTOM_LEFT.Y))) > 0);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function initBoundingBoxFromTexture(scene:CocoScene, W2:Float, H2:Float)
	{
		__mTemp.identity();

		__currentFrame.scaleX *= __image.__pixelRatioScale;
		__currentFrame.scaleY *= __image.__pixelRatioScale;
		__currentFrame.apply(__mTemp);
		__currentFrame.scaleX /= __image.__pixelRatioScale;
		__currentFrame.scaleY /= __image.__pixelRatioScale;

		//__currentFrame.apply(__mTemp);

		__vTemp.reset(-W2, -H2, 0, 1);
		__vREL_TOP_LEFT	= __mTemp.multiplyByVector(__vTemp);
		__vABS_TOP_LEFT	= scene.__modelViewMatrix.multiplyByVector(__vTemp);

		__vTemp.reset(W2, -H2, 0, 1);
		__vREL_TOP_RIGHT = __mTemp.multiplyByVector(__vTemp);
		__vABS_TOP_RIGHT = scene.__modelViewMatrix.multiplyByVector(__vTemp);

		__vTemp.reset(-W2, H2, 0, 1);
		__vREL_BOTTOM_LEFT = __mTemp.multiplyByVector(__vTemp);
		__vABS_BOTTOM_LEFT = scene.__modelViewMatrix.multiplyByVector(__vTemp);

		__vTemp.reset(W2, H2, 0, 1);
		__vREL_BOTTOM_RIGHT	= __mTemp.multiplyByVector(__vTemp);
		__vABS_BOTTOM_RIGHT = scene.__modelViewMatrix.multiplyByVector(__vTemp);

	    __hasBoundingBox = true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function initBoundingBoxFromChildren(scene:CocoScene)
	{
	    // This function calculates the bounding box of all our children.

	    __hasBoundingBox = false;

	    if(__children.size()==0)
	    	return;

	    var Child :CocoClip
	    var i :Integer;
		var vClip :String;

	    __vREL_TOP_LEFT.X = 100000;
		__vREL_TOP_RIGHT.X = -100000;
	    __vREL_TOP_LEFT.Y = 100000;
	    __vREL_BOTTOM_LEFT.Y = -100000;

        for(vClip in __children)
	    {
            Child = __children[vClip];
            if(Child.__hasBoundingBox)
            {
				if(Child.__vREL_TOP_LEFT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_TOP_LEFT.X;
				if(Child.__vREL_TOP_LEFT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_TOP_LEFT.X;
				if(Child.__vREL_TOP_LEFT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_TOP_LEFT.Y;
				if(Child.__vREL_TOP_LEFT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_TOP_LEFT.Y;

				if(Child.__vREL_TOP_RIGHT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_TOP_RIGHT.X;
				if(Child.__vREL_TOP_RIGHT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_TOP_RIGHT.X;
				if(Child.__vREL_TOP_RIGHT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_TOP_RIGHT.Y;
				if(Child.__vREL_TOP_RIGHT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_TOP_RIGHT.Y;

				if(Child.__vREL_BOTTOM_LEFT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_BOTTOM_LEFT.X;
				if(Child.__vREL_BOTTOM_LEFT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_BOTTOM_LEFT.X;
				if(Child.__vREL_BOTTOM_LEFT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_BOTTOM_LEFT.Y;
				if(Child.__vREL_BOTTOM_LEFT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_BOTTOM_LEFT.Y;

				if(Child.__vREL_BOTTOM_RIGHT.X < __vREL_TOP_LEFT.X) __vREL_TOP_LEFT.X = Child.__vREL_BOTTOM_RIGHT.X;
				if(Child.__vREL_BOTTOM_RIGHT.X > __vREL_TOP_RIGHT.X) __vREL_TOP_RIGHT.X = Child.__vREL_BOTTOM_RIGHT.X;
				if(Child.__vREL_BOTTOM_RIGHT.Y < __vREL_TOP_LEFT.Y) __vREL_TOP_LEFT.Y = Child.__vREL_BOTTOM_RIGHT.Y;
				if(Child.__vREL_BOTTOM_RIGHT.Y > __vREL_BOTTOM_LEFT.Y) __vREL_BOTTOM_LEFT.Y = Child.__vREL_BOTTOM_RIGHT.Y;
            }
	    }

	    __vREL_TOP_RIGHT.Y = __vREL_TOP_LEFT.Y;
	    __vREL_BOTTOM_LEFT.X = __vREL_TOP_LEFT.X;
	    __vREL_BOTTOM_RIGHT.X = __vREL_TOP_RIGHT.X;
	    __vREL_BOTTOM_RIGHT.Y = __vREL_BOTTOM_LEFT.Y;

	    __vABS_TOP_LEFT = scene.__modelViewMatrix.multiplyByVector(__vREL_TOP_LEFT);
	    __vABS_TOP_RIGHT = scene.__modelViewMatrix.multiplyByVector(__vREL_TOP_RIGHT);
	    __vABS_BOTTOM_LEFT = scene.__modelViewMatrix.multiplyByVector(__vREL_BOTTOM_LEFT);
	    __vABS_BOTTOM_RIGHT = scene.__modelViewMatrix.multiplyByVector(__vREL_BOTTOM_RIGHT);

		__mTemp.identity();

		__currentFrame.apply(__mTemp);

	    __vREL_TOP_LEFT = __mTemp.multiplyByVector(__vREL_TOP_LEFT);
	    __vREL_TOP_RIGHT = __mTemp.multiplyByVector(__vREL_TOP_RIGHT);
	    __vREL_BOTTOM_LEFT = __mTemp.multiplyByVector(__vREL_BOTTOM_LEFT);
	    __vREL_BOTTOM_RIGHT = __mTemp.multiplyByVector(__vREL_BOTTOM_RIGHT);

	    __hasBoundingBox = true;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function drawBoundingBox(scene:CocoScene, gl:WebGLRenderingContext)
	{
		if(!__hasBoundingBox) return;

		gl.disableVertexAttribArray(scene.__glProgram.GLSLiTexCoords);
		gl.disableVertexAttribArray(scene.__glProgram.GLSLiVecCoords);

		gl.useProgram(scene.__boundingBoxProgram);
		gl.enableVertexAttribArray(scene.__boundingBoxProgram.GLSLiVec2Coords);

		gl.bindBuffer(gl.ARRAY_BUFFER, scene.__boundingBoxBuffer);
		gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array([__vABS_TOP_LEFT.X, __vABS_TOP_LEFT.Y, __vABS_TOP_RIGHT.X, __vABS_TOP_RIGHT.Y, __vABS_BOTTOM_RIGHT.X, __vABS_BOTTOM_RIGHT.Y, __vABS_BOTTOM_LEFT.X, __vABS_BOTTOM_LEFT.Y]));
		gl.vertexAttribPointer(scene.__boundingBoxProgram.GLSLiVec2Coords, 2, gl.FLOAT, false, 0, 0);
		scene.__projectionMatrix.update(gl, scene.__boundingBoxProgram.GLSLuProjMat);
		gl.drawArrays(gl.LINE_LOOP, 0, 4);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);

		gl.disableVertexAttribArray(scene.__boundingBoxProgram.GLSLiVec2Coords);
		gl.useProgram(scene.__glProgram);

		gl.enableVertexAttribArray(scene.__glProgram.GLSLiTexCoords);
		gl.enableVertexAttribArray(scene.__glProgram.GLSLiVecCoords);
	}
}
