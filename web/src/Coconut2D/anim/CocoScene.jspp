"#export native"
"#export web"

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2014 www.coconut2D.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	   ______                _____
//	  / ____/___  _________ / ___/________  ____  ___
//	 / /   / __ \/ ___/ __ \\__ \/ ___/ _ \/ __ \/ _ \
//	/ /___/ /_/ / /__/ /_/ /__/ / /__/  __/ / / /  __/
//	\____/\____/\___/\____/____/\___/\___/_/ /_/\___/
//
// ==================================================================================================================================

"#include CocoClip.jspp"
"#include WebGLRenderingContext.jspp"

class CocoScene
{
	// Resources
	public var __sceneName:String;
	public var __imageSymbols:Array<CocoImage>;

	// Fixed View Port
	public var __fps:Float;
	public var __view_width:Float;
	public var __view_height:Float;
	public var __view_pixel_ratio:Float;
	public var __view_scale:Float;

	// Rendering
	public var __root:CocoClip;
	public var __modelViewMatrix:CocoMatrix;
	public var __projectionMatrix:CocoMatrix;
	public var __glProgram:WebGLProgram;
	public var __levelParents:Array<CocoClip>;

	public var __vertex_shader:String;
	public var __fragment_shader:String;

	public var __boundingBoxVertexShader:String;
	public var __boundingBoxFragmentShader:String;
	public var __boundingBoxProgram:WebGLProgram;
	public var __boundingBoxBuffer:WebGLBuffer;

	public var __ready:Boolean;
	public var __finished:Boolean;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor()
	{
		__sceneName 				= "";
		__view_width				= 0;
		__view_height				= 0;
		__view_pixel_ratio			= 0;
		__view_scale				= 1;
		__root 						= null;
		__modelViewMatrix			= null;
		__projectionMatrix 			= null;
		__glProgram					= null;
		__vertex_shader				= "attribute vec2 iVecCoords;attribute vec2 iTexCoords;uniform mat4 uProjMat;uniform mat4 uMVMat;uniform vec2 uSprSize;uniform vec2 uSprFrame;uniform vec2 uSprFlip;varying vec2 pTexCoord;void main(void){ gl_Position = uProjMat * uMVMat * vec4(iVecCoords, 0.0, 1.0); pTexCoord = vec2(((abs(iTexCoords.x - uSprFlip.x) + uSprFrame.x) * uSprSize.x), ((abs(iTexCoords.y - uSprFlip.y) + uSprFrame.y) * uSprSize.y));}";
		__fragment_shader			= "#ifdef GL_ES\nprecision lowp float;\n#endif\nuniform sampler2D uSampler;uniform vec4 uColor;varying vec2 pTexCoord;void main(void){ vec4 texColor = texture2D(uSampler, pTexCoord); float c = (texColor.r + texColor.g + texColor.b) / 3.0; gl_FragColor = vec4((1.0 - uColor.r) * c + texColor.r * uColor.r, (1.0 - uColor.g) * c + texColor.g * uColor.g, (1.0 - uColor.b) * c + texColor.b * uColor.b, texColor.a * uColor.a);}";
		__boundingBoxVertexShader 	= "attribute vec2 iVec2Coords;uniform mat4 uProjMat;void main(void) { gl_Position = uProjMat * vec4(iVec2Coords, 0.0, 1.0);}";
		__boundingBoxFragmentShader	= "#ifdef GL_ES\nprecision lowp float;\n#endif\nvoid main(void) { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);}";
		__boundingBoxProgram		= null;
		__boundingBoxBuffer			= null;
		__ready 					= false;
		__finished					= false;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		delete __root;
		delete __modelViewMatrix;
		delete __projectionMatrix;
		delete __glProgram;
		delete __boundingBoxProgram;
		delete __boundingBoxBuffer;

		var i:Integer;
		for(i = __imageSymbols.size() - 1; i >= 0; i--)
		{
			delete __imageSymbols[i];
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function getImageSymbol(symbolName:String) :CocoImage
	{
		for(var i:Integer = __imageSymbols.size() - 1; i >= 0; i--)
		{
			if(__imageSymbols[i].symbolName == symbolName)
				return __imageSymbols[i];
		}
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function newResourceImage(symbolName:String, baseUrl:String) :CocoImage
	{
		if(getImageSymbol(symbolName)) throw "Resource image " + symbolName + " already exists.";
		var img:CocoImage = new CocoImage();
		img.symbolName = symbolName;
		img.baseUrl = baseUrl;
		__imageSymbols.push(img);
		return img;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function prepare(gl:WebGLRenderingContext)
	{
		gl.disable(gl.DEPTH_TEST);
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
		gl.disable(gl.CULL_FACE);

		__boundingBoxProgram = makeProgram(gl, __boundingBoxVertexShader, __boundingBoxFragmentShader);
		gl.useProgram(__boundingBoxProgram);
		__boundingBoxProgram.GLSLiVec2Coords	= gl.getAttribLocation(__boundingBoxProgram, "iVec2Coords");
		__boundingBoxProgram.GLSLuProjMat		= gl.getUniformLocation(__boundingBoxProgram, "uProjMat");
		__boundingBoxBuffer	= gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, __boundingBoxBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), gl.DYNAMIC_DRAW);

		__glProgram = makeProgram(gl, __vertex_shader, __fragment_shader);
		gl.useProgram(__glProgram);

		__glProgram.GLSLiVecCoords 	= gl.getAttribLocation(__glProgram, "iVecCoords");
		gl.enableVertexAttribArray(__glProgram.GLSLiVecCoords);
		__glProgram.GLSLiTexCoords 	= gl.getAttribLocation(__glProgram, "iTexCoords");
		gl.enableVertexAttribArray(__glProgram.GLSLiTexCoords);
		__glProgram.GLSLuProjMat 	= gl.getUniformLocation(__glProgram, "uProjMat");
		__glProgram.GLSLuMVMat 		= gl.getUniformLocation(__glProgram, "uMVMat");
		__glProgram.GLSLuSprSize 	= gl.getUniformLocation(__glProgram, "uSprSize");
		__glProgram.GLSLuSprFrame 	= gl.getUniformLocation(__glProgram, "uSprFrame");
		__glProgram.GLSLuSprFlip 	= gl.getUniformLocation(__glProgram, "uSprFlip");
		__glProgram.GLSLuSampler 	= gl.getUniformLocation(__glProgram, "uSampler");
		__glProgram.GLSLuColor 		= gl.getUniformLocation(__glProgram, "uColor");

		__modelViewMatrix = new CocoMatrix();
		__modelViewMatrix.update(gl, __glProgram.GLSLuMVMat);
		__view_scale = this.__view_width>0 && this.__view_height>0 ? Math.min( Float(gl.canvas.width) / this.__view_width, Float(gl.canvas.height) / this.__view_height) : window.devicePixelRatio;
		__projectionMatrix = new CocoMatrix();

		if(window.deviceRotation)
		{
			var c:Float = Math.cos(window.deviceRotation);
			var s:Float = Math.sin(window.deviceRotation);
			var orthoWidth:Float = Math.abs(c * Float(gl.canvas.width) + s * Float(gl.canvas.height));
			var orthoHeight:Float = Math.abs(-s * Float(gl.canvas.width) + c * Float(gl.canvas.height));
			__projectionMatrix.ortho(-orthoWidth / 2.0, orthoWidth / 2.0, orthoHeight / 2.0,  -orthoHeight / 2.0, -1.0, 1.0);
			__projectionMatrix.rotateZ(-window.deviceRotation);
		}
		else
		{
			__projectionMatrix.ortho( -(Float(gl.canvas.width) / 2.0), Float(gl.canvas.width) / 2.0, Float(gl.canvas.height) / 2.0,  -(Float(gl.canvas.height) / 2.0), -1.0, 1.0);
		}

		__projectionMatrix.scale(__view_scale, __view_scale);
		__projectionMatrix.update(gl, __glProgram.GLSLuProjMat);

		__root.prepare(this);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function makeProgram(gl:WebGLRenderingContext, vs:String, fs:String) :WebGLProgram
	{
		var vshader:WebGLShader = gl.createShader(gl.VERTEX_SHADER);
		var fshader:WebGLShader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(vshader, vs);
		gl.shaderSource(fshader, fs);
		gl.compileShader(vshader);
		gl.compileShader(fshader);
		//if(!gl.getShaderParameter(vshader, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(vshader);
		//if(!gl.getShaderParameter(fshader, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(fshader);
		var program:WebGLProgram = gl.createProgram();
		gl.attachShader(program, vshader);
		gl.attachShader(program, fshader);
		gl.linkProgram(program);
		//if(!gl.getProgramParameter(program, gl.LINK_STATUS)) throw gl.getProgramInfoLog(program);
		return program;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function loadResources()
	{
		var img:CocoImage;
		var sibling:CocoImageSibling;

		// Load images depending on screen resolution and available image sizes.
		for(var i:Integer = 0, L:Integer = __imageSymbols.size(); i < L ; i++)
	    {
	    	img = __imageSymbols[i];
			if(__view_width && __view_height)
			{
				var w:Float = img.viewOptimalWidth * __view_scale * window.devicePixelRatio;
				var h:Float = img.viewOptimalHeight * __view_scale * window.devicePixelRatio;
				for(var j:Integer = 0; j < img.viewSiblings.size(); j++)
				{
					sibling = img.viewSiblings[j];
					if(sibling.textureWidth>=w && sibling.textureHeight>=h)
					{
						img.image = new Image();
						img.image.load(img.baseUrl + sibling.url);
						img.textureCellWidth = sibling.textureWidth;
						img.textureCellHeight = sibling.textureHeight;
						img.pixelRatio = sibling.pixelRatio;
						break;
					}
				}
			}
			if(!img.image)
			{
				sibling = img.viewSiblings[img.viewSiblings.size()-1];
				img.image = new Image();
				img.image.load(img.baseUrl + sibling.url);
				img.textureCellWidth = sibling.textureWidth;
				img.textureCellHeight = sibling.textureHeight;
				img.pixelRatio = sibling.pixelRatio;
			}

			if(img.image)
			{
				trace("Loaded image: " + img.image.src);
			}
	    }
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	private function resourcesLoaded(gl:WebGLRenderingContext) :Boolean
	{
		if(!__ready)
		{
			var img:CocoImage;
			for (var i:Integer = __imageSymbols.size() - 1; i >= 0; i--)
			{
				img = __imageSymbols[i];
				if (!img.image || !img.image.width || !img.image.height)
				{
					return false;
				}
				else if (!img.texture)
				{
					img.prepare(this, gl);
					return false;
				}
			}
			__ready = true;
			trace("Resources loaded.");
			return false;
		}
		return __ready;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public virtual function paint(gl:WebGLRenderingContext, time:Time)
	{
		if(!__glProgram)
		{
			prepare(gl);
			loadResources();
		}
		else if(resourcesLoaded(gl))
		{
		    if(__root)
		    {
				__modelViewMatrix.identity();
		    	__levelParents = [__root];
				__root.paint(gl, this, null, false, 0);
				__levelParents = [];
				var max:CocoClip = __root.__childWithMaxTimelineDuration;
				if(max && max.__currentFrame && max.__currentFrame.frameIndex == max.__timeline.lastKeyFrame().frameIndex)
				{
					__finished=true;
					//__root.reset();
					//__startTime = -1;
				}
		    }
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function drawFrame(gl:WebGLRenderingContext, image:CocoImage, frame:Integer, red:Float, green:Float, blue:Float, alpha:Float, flipH:Boolean, flipV:Boolean)
	{
		if(__modelViewMatrix.__dirty) __modelViewMatrix.update(gl, __glProgram.GLSLuMVMat);
		gl.uniform2f(__glProgram.GLSLuSprSize, image.texSize[0], image.texSize[1]);
		gl.uniform2f(__glProgram.GLSLuSprFrame, image.textureGrid[frame * 2 + 1], image.textureGrid[frame * 2]);
		gl.uniform2f(__glProgram.GLSLuSprFlip, (flipH ? 1.0 : 0.0), (flipV ? 1.0 : 0.0));
		gl.bindBuffer(gl.ARRAY_BUFFER, image.buffer);
		gl.vertexAttribPointer(__glProgram.GLSLiTexCoords, 2, gl.FLOAT, false, 16, 0);
		gl.vertexAttribPointer(__glProgram.GLSLiVecCoords, 2, gl.FLOAT, false, 16, 8);
		gl.bindTexture(gl.TEXTURE_2D, image.texture);
		gl.uniform1i(__glProgram.GLSLuSampler, 0);
		gl.uniform4f(__glProgram.GLSLuColor, red, green, blue, alpha);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		gl.bindBuffer(gl.ARRAY_BUFFER, null);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoAndPlayByName(LabelName:String, optional deep:Boolean)
	{
		var scope:CocoClip = __levelParents.size()==0 ? __root : __levelParents[__levelParents.size() - 1];
		scope.gotoFrameByName(LabelName, false, deep);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoAndStopByName(LabelName:String, optional deep:Boolean)
	{
		var scope:CocoClip = __levelParents.size()==0 ? __root : __levelParents[__levelParents.size() - 1];
		scope.gotoFrameByName(LabelName, true, deep);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoAndPlayByIndex(FrameIndex:Integer, optional deep:Boolean)
	{
		var scope:CocoClip = __levelParents.size()==0 ? __root : __levelParents[__levelParents.size() - 1];
		scope.gotoFrameByIndex(FrameIndex, false, deep);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function gotoAndStopyByIndex(FrameIndex:Integer, optional deep:Boolean)
	{
		var scope:CocoClip = __levelParents.size()==0 ? __root : __levelParents[__levelParents.size() - 1];
		scope.gotoFrameByIndex(FrameIndex, true, deep);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function stop()
	{
		var scope:CocoClip = __levelParents.size()==0 ? __root : __levelParents[__levelParents.size() - 1];
		scope.gotoFrameByIndex(COCO_STOP_ON_CURRENT_FRAME, true, false);
	}
}

