"#export native"
"#export web"

/* ***** BEGIN LICENSE BLOCK *****
 *
 * Copyright (C) 2013-2014 www.coconut2D.org
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

// ==================================================================================================================================
//	   ______               _______                ___
//	  / ____/___  _________/_  __(_)___ ___  ___  / (_)___  ___
//	 / /   / __ \/ ___/ __ \/ / / / __ `__ \/ _ \/ / / __ \/ _ \
//	/ /___/ /_/ / /__/ /_/ / / / / / / / / /  __/ / / / / /  __/
//	\____/\____/\___/\____/_/ /_/_/ /_/ /_/\___/_/_/_/ /_/\___/
//
// ==================================================================================================================================

"#include CocoKeyFrame.jspp"
"#include CocoTimeLabel.jspp"

class CocoTimeline
{
	public var __labels:Array<CocoTimeLabel>;
	public var __keyFrames:Array<CocoKeyFrame>;
	public var __singleFrameDurationTime:Time;
	public var __durationInTime:Time;
	public var __durationInFrames:Integer;
	public var __paused:Boolean;
	public var __fps:Float;
	public var __currentFrameIndex:Integer;
	public var __firstKeyFrameIndex:Integer;
	public var __lastKeyFrameIndex:Integer;

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function Constructor()
	{
		__singleFrameDurationTime	= 0.0;
		__durationInTime			= 0.0;
		__durationInFrames			= 0;
		__paused					= false;
		__fps						= 30;
		__currentFrameIndex			= -1;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////
	public function Destructor()
	{
		delete __labels;
		delete __keyFrames;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function prepare(scene:CocoScene, clip:CocoClip)
	{
		__fps = scene.__fps;
		normalizetimeline();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function clear()
	{
		reset();
		__keyFrames = [];
		__labels = [];
		normalizetimeline();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function reset()
	{
		__paused = false;
		__currentFrameIndex = -1;
		for (var i:Integer = __keyFrames.size() - 1; i >= 0; i--)
		{
			__keyFrames[i].reset();
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function addLabel(Label:CocoTimeLabel) :CocoTimeLabel
	{
		if (Label) __labels.push(Label);
		return Label;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function addLabelEx(FrameIndex:Integer, LabelName:String) :CocoTimeLabel
	{
		var Label:CocoTimeLabel = new CocoTimeLabel(FrameIndex, LabelName);
		return addLabel(Label);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function findLabelByName(LabelName:String) :CocoTimeLabel
	{
		for(var i:Integer = __labels.size() - 1; i >= 0; i--)
		{
			if(__labels[i].name == LabelName)
			{
				return __labels[i];
			}
		}
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function keyFrame(frameIndex:Integer) :CocoKeyFrame
	{
		for(var i:Integer = __keyFrames.size() - 1; i >= 0; i--)
		{
			if(__keyFrames[i].frameIndex == frameIndex)
			{
				return __keyFrames[i];
			}
		}
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function firstKeyFrame() :CocoKeyFrame
	{
		return __keyFrames[0];
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function lastKeyFrame() :CocoKeyFrame
	{
		return __keyFrames[__keyFrames.size() - 1];
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function addKeyFrame(KeyFrame:CocoKeyFrame) :CocoKeyFrame
	{
		if(KeyFrame)
		{
			KeyFrame.frameIndex = Math.floor(KeyFrame.frameIndex);
			__keyFrames.push(KeyFrame);
			normalizetimeline();
		}
		return KeyFrame;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function addKeyFrameEx(nextState:State,
								  actionCallback:CocoAction,
								  frameIndex:Integer,
								  frameInterpolation:COCO_KEYFRAME_INTERPOLATION_ENUM,
								  handleEvents:Boolean,
								  visible:Boolean,
								  x:Float,
								  y:Float,
								  scaleX:Float,
								  scaleY:Float,
								  rotation:Float,
								  pivotX:Float,
								  pivotY:Float,
								  filter:Integer,
								  red:Float,
								  green:Float,
								  blue:Float,
								  alpha:Float,
								  audio:CocoAudio,
								  flipH:Boolean,
								  flipV:Boolean,
								  spriteSequenceName:String) :CocoKeyFrame
	{
	    var KeyFrame:CocoKeyFrame = new CocoKeyFrame();

	    KeyFrame.nextState			= nextState;
	    KeyFrame.action				= actionCallback;
	    KeyFrame.frameIndex 		= frameIndex;
	    KeyFrame.frameInterpolation = frameInterpolation;
	    KeyFrame.handleEvents 		= handleEvents;
	    KeyFrame.visible 			= visible;
	    KeyFrame.filter				= filter;
	    KeyFrame.x 					= x;
	    KeyFrame.y 					= y;
	    KeyFrame.scaleX				= scaleX;
	    KeyFrame.scaleY				= scaleY;
	    KeyFrame.rotation 			= rotation;
	    KeyFrame.pivotX 			= pivotX;
	    KeyFrame.pivotY 			= pivotY;
	    KeyFrame.red 				= red;
	    KeyFrame.green 				= green;
	    KeyFrame.blue 				= blue;
	    KeyFrame.alpha 				= alpha;
	    KeyFrame.audio				= audio;
	    KeyFrame.flipH				= flipH;
	    KeyFrame.flipV				= flipV;
	    KeyFrame.spriteSequenceName	= spriteSequenceName;

	    return addKeyFrame(KeyFrame);
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function normalizetimeline()
	{
		__durationInFrames = 0;
		__durationInTime = 0;
		__singleFrameDurationTime = 0;
		if (__keyFrames.size() > 0)
		{
			__durationInFrames = __keyFrames[__keyFrames.size() - 1].frameIndex + 1;
			__singleFrameDurationTime = 1000.0 / __fps;
			__durationInTime = Time(__durationInFrames) * __singleFrameDurationTime;
			__firstKeyFrameIndex = firstKeyFrame().frameIndex;
			__lastKeyFrameIndex = lastKeyFrame().frameIndex;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function findKeyFrameBeforeframeIndex(frameIndex:Float, inclusive:Boolean, excludeListIndex:Float) :CocoKeyFrame
	{
		var KeyFrame:CocoKeyFrame;
		for (var i:Integer = __keyFrames.size() - 1; i >= 0; i--)
		{
			if (i != excludeListIndex)
			{
				KeyFrame = __keyFrames[i];
				if (inclusive)
				{
					if (KeyFrame.frameIndex <= frameIndex)
					return KeyFrame;
				}
				else
				{
					if (KeyFrame.frameIndex < frameIndex)
					return KeyFrame;
				}
			}
		}
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function findKeyFrameAfterframeIndex(frameIndex:Float, inclusive:Boolean, excludeListIndex:Float) :CocoKeyFrame
	{
		var KeyFrame:CocoKeyFrame;
		for(var i:Integer = 0, L:Integer = __keyFrames.size(); i < L; i++)
		{
			if (i != excludeListIndex)
			{
				KeyFrame = __keyFrames[i];
				if (inclusive)
				{
					if (KeyFrame.frameIndex >= frameIndex)
					return KeyFrame;
				}
				else
				{
					if (KeyFrame.frameIndex > frameIndex)
					return KeyFrame;
				}
			}
		}
		return null;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////
	public function interpolate(frameIndex:Float) :CocoKeyFrame
	{
	    var F:CocoKeyFrame = null;
	    var F1:CocoKeyFrame = null;
	    var F2:CocoKeyFrame = null;
	    var s:Float = 1.0;
	    var iFrameIndex:Integer = Math.floor(frameIndex);

	    // Timeline is empty?
	    if(__keyFrames.size()==0)
	    {
	        F = new CocoKeyFrame();
	        F.frameIndex = iFrameIndex;
	        F.visible = false;
	        return F;
	    }

	    // Seek previous KeyFrame
    	F1 = findKeyFrameBeforeframeIndex(frameIndex, true, -1);

	    if(!F1)
	    {
	        // No previous KeyFrame
	        F = new CocoKeyFrame();
	        F.frameIndex = iFrameIndex;
	        F.__frameIndex = frameIndex;
	        F.visible = false;
	        return F;
	    }
	    else
	    {
	    	var exact:Boolean = !__paused && ((__currentFrameIndex == -1) || (__currentFrameIndex != F1.frameIndex));
	    	__currentFrameIndex = F1.frameIndex;

	    	if(F1.frameIndex==iFrameIndex)
	    	{
	    		F1 = F1.clone(exact);
	    		F1.__frameIndex = frameIndex;
	    		return F1;
	    	}

	        switch(F1.frameInterpolation)
	        {
	        case COCO_KEYFRAME_INTERPOLATION_ENUM.KEYFRAME_INTERPOLATION_ECHO:

	            F = F1.clone(exact);
	            F.frameIndex = iFrameIndex;
	            F.__frameIndex = frameIndex;
	            return F;

	        case COCO_KEYFRAME_INTERPOLATION_ENUM.KEYFRAME_INTERPOLATION_NONE:

	            F = F1.clone(exact);
	            F.frameIndex = iFrameIndex;
	            F.__frameIndex = frameIndex;
	            F.visible = false;
	            return F;

	        case COCO_KEYFRAME_INTERPOLATION_ENUM.KEYFRAME_INTERPOLATION_MOTION_TWEEN:

	            // We need the next KeyFrame now
	            F2 = findKeyFrameAfterframeIndex(frameIndex, (frameIndex>iFrameIndex), -1);

	            if(!F2)
	            {
	                // Fallback to echo
	                F = F1.clone(exact);
	                F.frameIndex = iFrameIndex;
	                F.__frameIndex = frameIndex;
	                return F;
	            }
	            else
	            {
	                // Interpolate between frames
	                F = F1.clone(exact);
	                F.frameIndex = iFrameIndex;
	                F.__frameIndex = frameIndex;
	                s = Float((frameIndex - F1.frameIndex) / (F2.frameIndex - F1.frameIndex));
	                F.interpolate(F1, F2, s);
	                return F;
	            }

	        case COCO_KEYFRAME_INTERPOLATION_ENUM.KEYFRAME_INTERPOLATION_PHYSICS:
	        	break;
	        }
	    }
	    return null;
	}
}
